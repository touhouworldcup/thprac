#include "thprac_launcher_tools.h"
#include "thprac_launcher_utils.h"
#include "thprac_launcher_games.h"
#include "thprac_launcher_main.h"
#include "thprac_main.h"
#include "thprac_gui_locale.h"
#include "thprac_utils.h"
#include "utils/utils.h"
#include <functional>
#include <string>
#include <vector>
#include "..\3rdParties\rapidcsv\rapidcsv.h"
#include <numbers>
#include <format>
#include "thprac_launcher_tools_waifus.h"

#include <DirectXMath.h>
#include <d3d9.h>

namespace THPrac {

extern LPDIRECT3DDEVICE9 g_pd3dDevice;
void LauncherToolsGuiSwitch(const char* gameStr);

std::wstring NormalizePath(std::wstring path)
{
    std::replace(path.begin(), path.end(), L'/', L'\\');
    std::transform(path.begin(), path.end(), path.begin(), ::towupper);
    return path;
}

std::vector<std::wstring> THClearGame()
{
    std::vector<std::wstring> gameKilled;

    auto paths = GetAllGamePaths();
    std::vector<std::wstring> normalizedList;
    for (const auto& path : paths) {
        normalizedList.push_back(NormalizePath(path));
    }
    if (paths.empty())
        return gameKilled;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
        return gameKilled;
    PROCESSENTRY32W pe;
    pe.dwSize = sizeof(PROCESSENTRY32W);
    if (Process32FirstW(hSnapshot, &pe)) {
        do {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_TERMINATE, FALSE, pe.th32ProcessID);
            if (hProcess) {
                wchar_t processPath[MAX_PATH];
                DWORD dwSize = MAX_PATH;
                if (QueryFullProcessImageNameW(hProcess, 0, processPath, &dwSize)) {
                    std::wstring currentPath = NormalizePath(processPath);
                    auto it = std::find(normalizedList.begin(), normalizedList.end(), currentPath);
                    if (it != normalizedList.end()) {
                        if (TerminateProcess(hProcess, 9)) {
                            gameKilled.push_back(currentPath);
                        }
                    }
                }
                CloseHandle(hProcess);
            }
        } while (Process32NextW(hSnapshot, &pe));
    }
    CloseHandle(hSnapshot);
    return gameKilled;
}

class Dice {
public:
    DirectX::XMFLOAT3 pos;
    DirectX::XMMATRIX rot;

    DirectX::XMFLOAT4 q_last;
    DirectX::XMFLOAT4 q_final;
    DirectX::XMFLOAT4 q_start_tumble_axis;
    DirectX::XMFLOAT4 q_final_tumble_axis;
    float total_spin;

    Dice()
    {
        static auto distYaw = GetRndGenerator(DirectX::XM_2PI / 4.0f-0.2f, DirectX::XM_2PI / 4.0f+0.2f);
        size = 12.0f;
        pos = DirectX::XMFLOAT3(0, 0, 0);
        rot = DirectX::XMMatrixRotationY(distYaw());
    }
    ~Dice() = default;
    int GetResult(){
        using namespace DirectX;
        struct FaceDef {
            int id;
            XMFLOAT3 norm;
        };
        FaceDef faces[] = {
            { 1, { 0, 1, 0 } }, { 6, { 0, -1, 0 } },
            { 2, { 1, 0, 0 } }, { 5, { -1, 0, 0 } },
            { 3, { 0, 0, 1 } }, { 4, { 0, 0, -1 } }
        };
        XMVECTOR vUp = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
        int max_id = 1;
        float max_dot = -2.0f;
        for (const auto& face : faces) {
            XMVECTOR localNorm = XMLoadFloat3(&face.norm);
            XMVECTOR worldNorm = XMVector3TransformNormal(localNorm, rot);

            float dotVal = XMVectorGetX(XMVector3Dot(worldNorm, vUp));

            if (dotVal > max_dot) {
                max_dot = dotVal;
                max_id = face.id;
            }
        }
        return max_id;
    } 

    void Drop()
    {
        using namespace DirectX;
        XMVECTOR qCurrent = XMQuaternionRotationMatrix(rot);
        XMStoreFloat4(&q_last, qCurrent);

        static auto distFace = GetRndGenerator(0,5);
        static auto distYaw = GetRndGenerator(0.0f, XM_2PI);
        static auto distAxis = GetRndGeneratorNormal(-1.0f, 1.0f);
        static auto distSpin = GetRndGenerator(XM_2PI * 5.0f, XM_2PI * 8.0f);

        int targetFaceIndex = distFace();
        XMVECTOR qTargetBase = XMQuaternionIdentity();
        switch (targetFaceIndex) {
        case 0:
            qTargetBase = XMQuaternionIdentity();
            break;
        case 1:
            qTargetBase = XMQuaternionRotationAxis(XMVectorSet(1, 0, 0, 0), XM_PI);
            break;
        case 2:
            qTargetBase = XMQuaternionRotationAxis(XMVectorSet(0, 0, 1, 0), XM_PIDIV2);
            break;
        case 3:
            qTargetBase = XMQuaternionRotationAxis(XMVectorSet(0, 0, 1, 0), -XM_PIDIV2);
            break;
        case 4:
            qTargetBase = XMQuaternionRotationAxis(XMVectorSet(1, 0, 0, 0), -XM_PIDIV2);
            break;
        case 5:
            qTargetBase = XMQuaternionRotationAxis(XMVectorSet(1, 0, 0, 0), XM_PIDIV2);
            break;
        }
        // random y rotate
        XMVECTOR qYaw = XMQuaternionRotationAxis(XMVectorSet(0, 1, 0, 0), distYaw());
        XMVECTOR qFinalVec = XMQuaternionMultiply(qTargetBase, qYaw);
        XMStoreFloat4(&q_final, qFinalVec);
        XMStoreFloat4(&q_start_tumble_axis, XMQuaternionRotationAxis(XMVector3Normalize(XMVectorSet(distAxis(), distAxis(), distAxis(), 0.0f)), distSpin()));
        XMStoreFloat4(&q_final_tumble_axis, XMQuaternionRotationAxis(XMVector3Normalize(XMVectorSet(distAxis(), distAxis(), distAxis(), 0.0f)), distSpin()));

        total_spin = distSpin();
    }
    void Update(float t)
    {
        using namespace DirectX;
        t = std::max(0.0f, std::min(t, 1.0f));
        XMVECTOR qStart = XMLoadFloat4(&q_last);
        XMVECTOR qEnd = XMLoadFloat4(&q_final);

        float t_rot = t * t * (3.0f - 2.0f * t);
        XMVECTOR qBase = XMQuaternionSlerp(qStart, qEnd, t_rot);

        qStart = XMLoadFloat4(&q_start_tumble_axis);
        qEnd = XMLoadFloat4(&q_final_tumble_axis);
        XMVECTOR qBase_axis = XMQuaternionSlerp(qStart, qEnd, t_rot);

        float spinAngle = total_spin * std::pow(1.0f - t, 2.0f);
        auto tumble_axis = XMFLOAT3(0, 1, 0);
        XMVECTOR vAxis = XMLoadFloat3(&tumble_axis);
        vAxis = XMQuaternionMultiply(vAxis, qBase_axis);

        XMVECTOR qSpin = XMQuaternionRotationAxis(vAxis, spinAngle);

        XMVECTOR qResult = XMQuaternionMultiply(qBase, qSpin);
        rot = XMMatrixRotationQuaternion(qResult);
    }

    void Render(std::vector<ImVec2>& points, std::vector<int>& dice_num)
    {
        using namespace DirectX;
        points.clear();
        dice_num.clear();
        auto eye_f = XMFLOAT3(18, 35, 0);
        XMVECTOR vEye = XMLoadFloat3(&eye_f);

        auto at_f = XMFLOAT3(0, 0, 0);
        XMVECTOR vAt = XMLoadFloat3(&at_f);

        auto up_f = XMFLOAT3(0, 1, 0);
        XMVECTOR vUp = XMLoadFloat3(&up_f);

        XMMATRIX mView, mProj, mVP, mWorld, mTrans;
        mView = DirectX::XMMatrixLookAtLH(vEye, vAt, vUp);
        mProj = DirectX::XMMatrixOrthographicLH(80.0f, 80.0f, 0.1f, 100.0f);
        mVP = DirectX::XMMatrixMultiply(mView, mProj);
        mTrans = DirectX::XMMatrixTranslation(pos.x, pos.y, pos.z);
        mWorld = DirectX::XMMatrixMultiply(rot, mTrans);
        struct Face {
            int id;
            XMFLOAT3 norm;
            XMFLOAT3 v[4];
        };
        float s = size;
        Face faces[6];
        //Face ground;
        //float gs = 3.0f;
        //ground = { -1, { 0, 1, 0 }, { { -s * gs, 0, s * gs }, { s * gs, 0, s * gs }, { s * gs, 0, -s * gs }, { -s * gs, 0, -s * gs } } };

        //Y+/-
        faces[0] = { 1, { 0, 1, 0 }, { { -s, s, s }, { s, s, s }, { s, s, -s }, { -s, s, -s } } };
        faces[1] = { 6, { 0, -1, 0 }, { { -s, -s, -s }, { s, -s, -s }, { s, -s, s }, { -s, -s, s } } };
        //X+/-
        faces[2] = { 2, { 1, 0, 0 }, { { s, s, -s }, { s, s, s }, { s, -s, s }, { s, -s, -s } } };
        faces[3] = { 5, { -1, 0, 0 }, { { -s, s, s }, { -s, s, -s }, { -s, -s, -s }, { -s, -s, s } } };
        //Z+/-
        faces[4] = { 3, { 0, 0, 1 }, { { s, s, s }, { -s, s, s }, { -s, -s, s }, { s, -s, s } } };
        faces[5] = { 4, { 0, 0, -1 }, { { -s, s, -s }, { s, s, -s }, { s, -s, -s }, { -s, -s, -s } } };

        auto viewDir_f = XMFLOAT3(-eye_f.x,-eye_f.y,-eye_f.z);
        XMVECTOR viewDir = XMLoadFloat3(&viewDir_f);
        // dice_num.push_back(7);
        // for (int k = 0; k < 4; k++) {
        //     auto pt = XMLoadFloat3(&ground.v[k]);
        //     auto vp = XMVector3TransformCoord(pt, mVP);
        //     XMFLOAT3 vp_f;
        //     XMStoreFloat3(&vp_f, vp);
        //     points.push_back({ (vp_f.x + 1.0f) * 0.5f, (1.0f - vp_f.y) * 0.5f });
        // }

        for (int i = 0; i < 6; i++) {
            auto norm = XMLoadFloat3(&faces[i].norm);
            auto wNorm = XMVector3TransformNormal(norm, rot);
            XMFLOAT3 dotval;
            XMStoreFloat3(&dotval,XMVector3Dot(wNorm, viewDir));
            if (dotval.x <= 0) {
                dice_num.push_back(faces[i].id);
                for (int k = 0; k < 4; k++) {
                    auto pt = XMLoadFloat3(&faces[i].v[k]);
                    auto vw = XMVector3TransformCoord(pt, mWorld);
                    auto vp = XMVector3TransformCoord(vw, mVP);
                    XMFLOAT3 vp_f;
                    XMStoreFloat3(&vp_f, vp);
                    points.push_back({ (vp_f.x + 1.0f) * 0.5f, (1.0f - vp_f.y) * 0.5f });
                }
            }
        }
    }
private:
    float size;
};

class THGuiDice {
public:
    struct DiceT
    {
        Dice dice;
        bool is_playing;
        float t;
    };
    std::vector<DiceT> dices;
    int max_dice = 16;

    ImTextureID texes[6];

    THGuiDice()
        : dices()
    {
        dices.push_back({ Dice(),false,0.0f });
        InitImage();
    }

    void InitImage()
    {
        const static uint8_t data1[800] = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0xAA, 0x69, 0x71, 
    0xDE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x13, 0x00, 0x00, 0x0B, 
    0x13, 0x01, 0x00, 0x9A, 0x9C, 0x18, 0x00, 0x00, 0x02, 0xD2, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 
    0xED, 0x9A, 0x4B, 0x48, 0x54, 0x61, 0x1C, 0x47, 0xCF, 0x9D, 0xB9, 0x33, 0x9A, 0xA3, 0xF9, 0xC0, 
    0x10, 0x2C, 0xED, 0x81, 0xC8, 0x88, 0x96, 0xB8, 0xA8, 0x24, 0xA2, 0x90, 0xDA, 0x04, 0x45, 0x8B, 
    0x28, 0x69, 0x61, 0x50, 0x51, 0x90, 0x54, 0x0B, 0x37, 0x51, 0x51, 0x8B, 0xA2, 0xD7, 0xC6, 0x45, 
    0x45, 0x85, 0x51, 0x41, 0xB6, 0x31, 0xAA, 0x4D, 0x41, 0x9B, 0x42, 0x92, 0x08, 0xAD, 0x85, 0x58, 
    0x49, 0x22, 0xD1, 0x43, 0x4B, 0x88, 0xC2, 0x34, 0x1D, 0x73, 0x66, 0xEE, 0xCC, 0x6D, 0x21, 0x66, 
    0xC5, 0x44, 0xC8, 0x7C, 0xDF, 0xFC, 0x03, 0xBF, 0xB3, 0x9E, 0xF9, 0xDD, 0x33, 0x87, 0x79, 0xDD, 
    0x3B, 0x63, 0xC5, 0xE3, 0x71, 0x97, 0x19, 0x8C, 0x47, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 
    0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 
    0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 
    0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x9A, 0x19, 0x1F, 0xC0, 0x4E, 0xE9, 0xD1, 0x62, 
    0x31, 0xA2, 0xAF, 0xBA, 0x88, 0xF6, 0x76, 0x13, 0x1F, 0xFC, 0x82, 0x3B, 0x16, 0xC2, 0x93, 0x93, 
    0x87, 0x67, 0x4E, 0x01, 0xFE, 0xCA, 0x65, 0x78, 0x0B, 0x8B, 0x52, 0xAA, 0x03, 0x29, 0x0A, 0xE0, 
    0x86, 0x46, 0x18, 0xBB, 0xDD, 0x4C, 0xE8, 0xE6, 0x55, 0x9C, 0xD7, 0x3D, 0x89, 0x6F, 0x64, 0x41, 
    0xFA, 0x9A, 0xF5, 0x04, 0x6A, 0x77, 0x92, 0xB6, 0x72, 0x2D, 0x58, 0x56, 0x2A, 0xD4, 0xB0, 0x74, 
    0x5F, 0x16, 0x0F, 0x77, 0xB4, 0x31, 0x7C, 0xBC, 0xE1, 0xEF, 0x0F, 0x3C, 0x01, 0xB3, 0x36, 0xD4, 
    0x32, 0xFB, 0xC0, 0x49, 0xBC, 0xF9, 0x05, 0x1A, 0xCD, 0x26, 0xD0, 0x1A, 0x60, 0xEC, 0xCE, 0x0D, 
    0x86, 0x8F, 0xEE, 0xC5, 0x75, 0x9C, 0x69, 0xDF, 0xD7, 0x57, 0x51, 0x45, 0xEE, 0xE9, 0x26, 0xEC, 
    0x92, 0x32, 0x0D, 0x66, 0x53, 0x68, 0x0B, 0x30, 0xDE, 0x7A, 0x9F, 0xC1, 0xFA, 0xCD, 0x90, 0xC4, 
    0xBA, 0xAF, 0xA2, 0x8A, 0xBC, 0x4B, 0xB7, 0xB4, 0x3E, 0x13, 0xB4, 0x7C, 0x0A, 0xC4, 0x3E, 0xBC, 
    0x63, 0xE8, 0xE0, 0xEE, 0xA4, 0x1E, 0x3C, 0x40, 0xF4, 0x65, 0x27, 0xDF, 0xCE, 0x1C, 0x02, 0x57, 
    0xDF, 0xAB, 0x54, 0x4B, 0x80, 0xD1, 0xEB, 0x17, 0x88, 0x0F, 0x7D, 0x55, 0xB2, 0xF5, 0xFD, 0x6E, 
    0x0B, 0xE1, 0xC7, 0x0F, 0x94, 0x6C, 0x25, 0x42, 0x79, 0x00, 0xA7, 0xEF, 0x0D, 0xA1, 0xE6, 0x8B, 
    0x4A, 0x37, 0x43, 0x2D, 0x57, 0x94, 0xEE, 0xFD, 0x8A, 0xF2, 0x00, 0x91, 0xF6, 0x47, 0xCA, 0x9F, 
    0xB2, 0xE3, 0x0F, 0xEF, 0x11, 0x1B, 0xE8, 0x57, 0xBA, 0x39, 0x89, 0xFA, 0x00, 0x9D, 0xED, 0xAA, 
    0x27, 0xC1, 0x85, 0x48, 0xD7, 0x53, 0xF5, 0xBB, 0x68, 0x08, 0x10, 0xFB, 0xF8, 0x5E, 0xF5, 0x24, 
    0x00, 0xF1, 0xCF, 0x9F, 0xB4, 0xEC, 0x2A, 0x0F, 0x10, 0xED, 0xED, 0x56, 0x3D, 0x09, 0x40, 0x7C, 
    0x68, 0x50, 0xCB, 0xAE, 0xF2, 0x00, 0xDE, 0xC2, 0x62, 0xD5, 0x93, 0x00, 0x58, 0x19, 0x01, 0x2D, 
    0xBB, 0xCA, 0x03, 0xD8, 0x45, 0x0B, 0x55, 0x4F, 0x02, 0xE0, 0xC9, 0xCB, 0xD7, 0xB3, 0xAB, 0x7A, 
    0xD0, 0x0E, 0x2E, 0x56, 0x3D, 0x09, 0x80, 0xAF, 0xB4, 0x5C, 0xCB, 0xAE, 0xF2, 0x00, 0x69, 0xCB, 
    0x57, 0xA9, 0x9E, 0xC4, 0x2E, 0x09, 0xE2, 0x2B, 0xAB, 0x54, 0xBE, 0x0B, 0x1A, 0x02, 0xF8, 0x97, 
    0x2C, 0x9D, 0x38, 0x9D, 0x55, 0x48, 0x60, 0xCB, 0x0E, 0xF0, 0x7A, 0x95, 0x6E, 0x4E, 0xA2, 0xFE, 
    0xAB, 0xB0, 0x6D, 0x93, 0xB9, 0x7D, 0xBF, 0xBA, 0xB9, 0x92, 0x20, 0x19, 0x9B, 0xEA, 0x94, 0xED, 
    0xFD, 0x89, 0x96, 0x73, 0x81, 0xB4, 0x15, 0x35, 0x64, 0xEE, 0x6A, 0x48, 0x7A, 0xC7, 0xB2, 0x6D, 
    0xB2, 0x8F, 0x34, 0x62, 0x05, 0xB2, 0x14, 0x58, 0x25, 0x46, 0xCF, 0x35, 0x41, 0xCB, 0x22, 0x6B, 
    0xDF, 0x61, 0x32, 0x36, 0x6E, 0x4D, 0x62, 0x03, 0xB2, 0x8F, 0x9D, 0xD7, 0xF2, 0x9E, 0xF2, 0xDB, 
    0x61, 0x74, 0x5E, 0x10, 0x71, 0x23, 0x61, 0x46, 0xCE, 0x9D, 0x60, 0xF4, 0x72, 0xE3, 0xB4, 0xEE, 
    0xE7, 0xC9, 0xC9, 0x25, 0xE7, 0x54, 0x13, 0xE9, 0x35, 0xEB, 0x34, 0x99, 0x4D, 0xA1, 0xFD, 0x92, 
    0x18, 0xAE, 0x4B, 0xF8, 0x49, 0x2B, 0xA3, 0xD7, 0xCE, 0xFE, 0xFB, 0xB4, 0xD6, 0xB2, 0x08, 0xD4, 
    0xED, 0x21, 0x73, 0x5B, 0x3D, 0xDE, 0x79, 0x0B, 0xB4, 0x6A, 0xFD, 0x3C, 0x64, 0xCA, 0xFE, 0x2A, 
    0xEB, 0x38, 0x44, 0x9E, 0x3F, 0x23, 0xDC, 0xD1, 0x86, 0xD3, 0xF3, 0x02, 0xA7, 0xFF, 0x2D, 0xB1, 
    0x81, 0x3E, 0x7C, 0xA5, 0xE5, 0x78, 0xE7, 0xCE, 0xC7, 0x5F, 0x55, 0x8D, 0xBF, 0x7A, 0x35, 0x76, 
    0xF1, 0xA2, 0x94, 0xE8, 0x4C, 0x92, 0xBA, 0x00, 0xFF, 0x29, 0x33, 0xFE, 0x87, 0x11, 0x13, 0x40, 
    0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 
    0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 
    0x1A, 0x13, 0x40, 0x5A, 0x40, 0x1A, 0x13, 0x40, 0x5A, 0x40, 0x9A, 0x1F, 0x5F, 0xF6, 0xBC, 0x75, 
    0xDA, 0x6F, 0x66, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82, 
};
        
        const static uint8_t data2[724] = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0xAA, 0x69, 0x71, 
    0xDE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x13, 0x00, 0x00, 0x0B, 
    0x13, 0x01, 0x00, 0x9A, 0x9C, 0x18, 0x00, 0x00, 0x02, 0x86, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 
    0xED, 0x9A, 0x4F, 0x0B, 0x29, 0x51, 0x18, 0xC6, 0x9F, 0x99, 0x44, 0x21, 0x35, 0x29, 0xD9, 0xD8, 
    0x28, 0x65, 0xA7, 0x28, 0x12, 0x2B, 0x59, 0xFA, 0x06, 0x8A, 0x9D, 0x90, 0x85, 0x8F, 0x62, 0xE1, 
    0x0B, 0x50, 0xBE, 0x81, 0xA5, 0xEC, 0x10, 0x65, 0x61, 0xA7, 0x94, 0x8D, 0x92, 0x94, 0xA6, 0x24, 
    0x45, 0x3A, 0xEE, 0xEA, 0xAE, 0xCC, 0xC9, 0x9F, 0x7B, 0xEA, 0x3D, 0xA7, 0x7B, 0x7E, 0xCB, 0x39, 
    0xF3, 0x4E, 0xCF, 0xFC, 0x30, 0x63, 0x9A, 0xC7, 0x60, 0x8C, 0x3D, 0xF1, 0x1F, 0x63, 0x52, 0x07, 
    0xA0, 0x46, 0x0B, 0xA0, 0x0E, 0x40, 0x8D, 0x8B, 0x3A, 0x80, 0x08, 0xCE, 0xE7, 0x33, 0x76, 0xBB, 
    0x1D, 0x2E, 0x97, 0x0B, 0x3C, 0x1E, 0x0F, 0x42, 0xA1, 0x10, 0xC2, 0xE1, 0x30, 0x4C, 0xF3, 0xFD, 
    0xE7, 0xAB, 0xAC, 0x80, 0xC7, 0xE3, 0x81, 0xED, 0x76, 0x8B, 0x7E, 0xBF, 0x8F, 0xD1, 0x68, 0x04, 
    0xDB, 0xB6, 0xC1, 0x18, 0x83, 0x69, 0x9A, 0x70, 0xB9, 0x5C, 0x48, 0xA7, 0xD3, 0x28, 0x97, 0xCB, 
    0xC8, 0x66, 0xB3, 0xF0, 0xF9, 0x7C, 0xDC, 0xE3, 0x18, 0xAA, 0xDE, 0x05, 0x86, 0xC3, 0x21, 0x3A, 
    0x9D, 0x0E, 0xD6, 0xEB, 0x35, 0x9E, 0x4F, 0xE7, 0x53, 0xB0, 0x2C, 0x0B, 0xD5, 0x6A, 0x15, 0x8D, 
    0x46, 0x03, 0x7E, 0xBF, 0xDF, 0x71, 0x1F, 0xE5, 0x04, 0x30, 0xC6, 0x30, 0x9D, 0x4E, 0x51, 0xAF, 
    0xD7, 0x61, 0xDB, 0xF6, 0xDB, 0xFD, 0xBD, 0x5E, 0x2F, 0x6A, 0xB5, 0x1A, 0x9A, 0xCD, 0xA6, 0xE3, 
    0x37, 0x41, 0xB9, 0x8B, 0xE0, 0xE1, 0x70, 0x40, 0xA7, 0xD3, 0xF9, 0xE8, 0xE4, 0x01, 0xE0, 0x7A, 
    0xBD, 0xA2, 0xD7, 0xEB, 0x61, 0x36, 0x9B, 0x39, 0xAE, 0x2B, 0x27, 0x60, 0x34, 0x1A, 0x61, 0xB9, 
    0x5C, 0x7E, 0x35, 0x63, 0xDB, 0x36, 0x06, 0x83, 0x01, 0x18, 0x63, 0x2F, 0x6B, 0xCA, 0x09, 0x98, 
    0x4C, 0x26, 0xB8, 0xDF, 0xEF, 0x5F, 0xCF, 0x2D, 0x16, 0x0B, 0x1C, 0x0E, 0x87, 0x97, 0xED, 0xCA, 
    0x09, 0xD8, 0x6C, 0x36, 0x3F, 0xCD, 0x3D, 0x1E, 0x0F, 0x1C, 0x8F, 0xC7, 0x97, 0xED, 0xCA, 0x09, 
    0x38, 0x9D, 0x4E, 0x3F, 0xCD, 0x31, 0xC6, 0x70, 0xBB, 0xDD, 0x5E, 0xB6, 0x2B, 0x27, 0x20, 0x12, 
    0x89, 0xFC, 0x34, 0x67, 0x9A, 0xA6, 0xE3, 0xAD, 0x50, 0x39, 0x01, 0x89, 0x44, 0xE2, 0xA7, 0x39, 
    0xCB, 0xB2, 0x1C, 0xE5, 0x29, 0x27, 0xA0, 0x50, 0x28, 0x20, 0x18, 0x0C, 0x7E, 0x35, 0x63, 0x18, 
    0x06, 0x8A, 0xC5, 0x22, 0x02, 0x81, 0xC0, 0xCB, 0x9A, 0x72, 0x02, 0x32, 0x99, 0x0C, 0x4A, 0xA5, 
    0x12, 0x0C, 0xC3, 0xF8, 0x78, 0x26, 0x1E, 0x8F, 0xA3, 0x52, 0xA9, 0x38, 0xAE, 0x29, 0x27, 0xC0, 
    0xEF, 0xF7, 0xA3, 0xD5, 0x6A, 0x21, 0x99, 0x4C, 0x7E, 0x24, 0xC1, 0xB2, 0x2C, 0xB4, 0xDB, 0x6D, 
    0x44, 0xA3, 0x51, 0xC7, 0x75, 0xE5, 0xFE, 0x0A, 0xFF, 0x65, 0xBF, 0xDF, 0xA3, 0xDB, 0xED, 0x62, 
    0x38, 0x1C, 0x3A, 0xDE, 0x19, 0xDC, 0x6E, 0x37, 0x52, 0xA9, 0x14, 0xDA, 0xED, 0x36, 0xF2, 0xF9, 
    0x3C, 0xF7, 0x38, 0xCA, 0x0A, 0x00, 0x80, 0xCB, 0xE5, 0x82, 0xF9, 0x7C, 0x8E, 0xF1, 0x78, 0x8C, 
    0xD5, 0x6A, 0x85, 0xDD, 0x6E, 0x87, 0x60, 0x30, 0x88, 0x58, 0x2C, 0x86, 0x5C, 0x2E, 0x87, 0x62, 
    0xB1, 0xF8, 0xF6, 0xB1, 0x58, 0x69, 0x01, 0x22, 0x50, 0xEE, 0x1A, 0x20, 0x1A, 0x2D, 0x80, 0x3A, 
    0x00, 0x35, 0x5A, 0x00, 0x75, 0x00, 0x6A, 0xB4, 0x00, 0xEA, 0x00, 0xD4, 0x68, 0x01, 0xD4, 0x01, 
    0xA8, 0xD1, 0x02, 0xA8, 0x03, 0x50, 0xA3, 0x05, 0x50, 0x07, 0xA0, 0x46, 0x0B, 0xA0, 0x0E, 0x40, 
    0x8D, 0x16, 0x40, 0x1D, 0x80, 0x1A, 0x2D, 0x80, 0x3A, 0x00, 0x35, 0x5A, 0x00, 0x75, 0x00, 0x6A, 
    0xBE, 0x2A, 0x49, 0xFD, 0x4B, 0x1B, 0x4B, 0x56, 0xDE, 0x0A, 0x10, 0xD5, 0xC6, 0x92, 0x95, 0xB7, 
    0xEF, 0x05, 0x44, 0xB5, 0xB1, 0x64, 0x85, 0x2B, 0x40, 0x74, 0x1B, 0x4B, 0x56, 0xB8, 0x3F, 0x5E, 
    0xD1, 0x6D, 0x2C, 0x59, 0xE1, 0x0A, 0x10, 0xDD, 0xC6, 0x92, 0x15, 0xAE, 0x00, 0xD1, 0x6D, 0x2C, 
    0x59, 0xE1, 0x0A, 0x10, 0xDD, 0xC6, 0x92, 0x15, 0xAE, 0x00, 0xD1, 0x6D, 0x2C, 0x59, 0xE1, 0x0A, 
    0x10, 0xDD, 0xC6, 0x92, 0x15, 0xAE, 0x00, 0xD1, 0x6D, 0x2C, 0x59, 0xE1, 0x0A, 0x10, 0xDD, 0xC6, 
    0x92, 0x15, 0xAE, 0x00, 0xD1, 0x6D, 0x2C, 0x59, 0xE1, 0x0A, 0x10, 0xDD, 0xC6, 0x92, 0x95, 0xB7, 
    0xCF, 0x02, 0xA2, 0xDA, 0x58, 0xB2, 0xF2, 0x51, 0x49, 0x4A, 0x44, 0x1B, 0x4B, 0x56, 0x74, 0x4B, 
    0x8C, 0x3A, 0x00, 0x35, 0x5A, 0x00, 0x75, 0x00, 0x6A, 0xB4, 0x00, 0xEA, 0x00, 0xD4, 0xFC, 0x01, 
    0xBC, 0xC7, 0x49, 0x34, 0x4A, 0xBA, 0x88, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 
    0xAE, 0x42, 0x60, 0x82, 
};
        
        const static uint8_t data3[767] = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0xAA, 0x69, 0x71, 
    0xDE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x13, 0x00, 0x00, 0x0B, 
    0x13, 0x01, 0x00, 0x9A, 0x9C, 0x18, 0x00, 0x00, 0x02, 0xB1, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 
    0xED, 0x98, 0x4F, 0xCB, 0x31, 0x51, 0x18, 0x87, 0x7F, 0xC3, 0x28, 0x94, 0xA2, 0xEC, 0x90, 0x6C, 
    0x64, 0x2B, 0x7C, 0x01, 0xC9, 0x72, 0x16, 0x96, 0xB6, 0xF2, 0x89, 0x2C, 0xE5, 0x2B, 0x48, 0x96, 
    0xF2, 0x05, 0x84, 0x6C, 0x65, 0x23, 0x61, 0x23, 0x35, 0xA4, 0x66, 0x2C, 0x98, 0xF3, 0xAE, 0x2C, 
    0x9E, 0xDE, 0x72, 0xE6, 0xE9, 0xBD, 0xE7, 0xFC, 0xE9, 0x9D, 0x6B, 0xEB, 0x6E, 0xBA, 0xCF, 0xD5, 
    0x34, 0x4E, 0x97, 0xE1, 0x79, 0x1E, 0xC3, 0x7F, 0x4C, 0x44, 0xF6, 0x02, 0xB2, 0x09, 0x05, 0xC8, 
    0x5E, 0x40, 0x36, 0xA1, 0x00, 0xD9, 0x0B, 0xC8, 0xC6, 0x94, 0xBD, 0xC0, 0xBF, 0xF0, 0x7E, 0xBF, 
    0xE1, 0x38, 0x0E, 0x3C, 0xCF, 0x83, 0x69, 0x9A, 0x88, 0xC7, 0xE3, 0x88, 0x46, 0xA3, 0xBF, 0x7A, 
    0x86, 0x76, 0x02, 0x18, 0x63, 0x70, 0x1C, 0x07, 0xDB, 0xED, 0x16, 0xEB, 0xF5, 0x1A, 0x87, 0xC3, 
    0x01, 0xAF, 0xD7, 0x0B, 0x89, 0x44, 0x02, 0xA5, 0x52, 0x09, 0xF5, 0x7A, 0x1D, 0xE5, 0x72, 0x19, 
    0xB1, 0x58, 0xCC, 0xD7, 0xF3, 0xB4, 0x13, 0x60, 0xDB, 0x36, 0xA6, 0xD3, 0x29, 0xC6, 0xE3, 0x31, 
    0x76, 0xBB, 0x1D, 0x5C, 0xD7, 0x05, 0x63, 0x0C, 0x86, 0x61, 0x20, 0x95, 0x4A, 0xA1, 0x52, 0xA9, 
    0xA0, 0xDF, 0xEF, 0xA3, 0xD9, 0x6C, 0xFA, 0x92, 0xA0, 0x95, 0x00, 0xC7, 0x71, 0x30, 0x99, 0x4C, 
    0x30, 0x18, 0x0C, 0x70, 0xBD, 0x5E, 0xE1, 0x79, 0xDE, 0x8F, 0xDF, 0x6D, 0xDB, 0xC6, 0x62, 0xB1, 
    0xC0, 0xFD, 0x7E, 0x07, 0x00, 0x5F, 0x12, 0xB4, 0xFA, 0x08, 0xAE, 0x56, 0x2B, 0x8C, 0x46, 0x23, 
    0x5C, 0x2E, 0x97, 0xBF, 0x0E, 0xFF, 0xC1, 0xF3, 0x3C, 0x6C, 0xB7, 0x5B, 0x0C, 0x87, 0x43, 0xEC, 
    0x76, 0x3B, 0xEE, 0x33, 0xB5, 0x12, 0x30, 0x9B, 0xCD, 0x70, 0x3C, 0x1E, 0xB9, 0x73, 0x1F, 0x09, 
    0xAB, 0xD5, 0x0A, 0xEF, 0xF7, 0xFB, 0xEB, 0xAC, 0x56, 0x02, 0x36, 0x9B, 0x0D, 0xF7, 0x40, 0x1F, 
    0x1E, 0x8F, 0x07, 0xF6, 0xFB, 0x3D, 0x9E, 0xCF, 0xE7, 0xD7, 0x39, 0xAD, 0x04, 0x9C, 0xCF, 0x67, 
    0xDF, 0xB3, 0x8C, 0x31, 0xB8, 0xAE, 0x8B, 0xD7, 0xEB, 0xF5, 0x75, 0x4E, 0x2B, 0x01, 0xE9, 0x74, 
    0xDA, 0xF7, 0xAC, 0x61, 0x18, 0x30, 0x4D, 0x13, 0x91, 0xC8, 0xF7, 0x23, 0x6A, 0x25, 0xA0, 0xD1, 
    0x68, 0x70, 0x0F, 0xF4, 0x21, 0x91, 0x48, 0xA0, 0x58, 0x2C, 0x22, 0x99, 0x4C, 0x7E, 0x9D, 0xD3, 
    0x4A, 0x40, 0xAB, 0xD5, 0x42, 0x3E, 0x9F, 0xE7, 0xCE, 0x45, 0x22, 0x11, 0x94, 0xCB, 0x65, 0xD4, 
    0x6A, 0x35, 0xEE, 0xCD, 0x50, 0x2B, 0x01, 0x8D, 0x46, 0x03, 0x96, 0x65, 0x21, 0x95, 0x4A, 0x7D, 
    0x9D, 0xCB, 0x66, 0xB3, 0xE8, 0x74, 0x3A, 0xA8, 0x54, 0x2A, 0xDC, 0x67, 0x6A, 0x75, 0x11, 0xCA, 
    0x64, 0x32, 0xE8, 0x76, 0xBB, 0x00, 0x80, 0xE9, 0x74, 0x8A, 0xD3, 0xE9, 0xF4, 0xE3, 0x3E, 0x10, 
    0x8D, 0x46, 0x51, 0x28, 0x14, 0xD0, 0xEB, 0xF5, 0x60, 0x59, 0x16, 0xF7, 0xF5, 0x07, 0x00, 0x43, 
    0xB7, 0x24, 0xC6, 0x18, 0x83, 0x6D, 0xDB, 0x58, 0x2E, 0x97, 0x98, 0xCF, 0xE7, 0x58, 0x2E, 0x97, 
    0xB8, 0xDD, 0x6E, 0xC8, 0xE5, 0x72, 0xA8, 0x56, 0xAB, 0x68, 0xB7, 0xDB, 0xA8, 0xD7, 0xEB, 0xBE, 
    0x0E, 0x0F, 0x68, 0x28, 0x80, 0x1A, 0xAD, 0xBE, 0x01, 0x41, 0x10, 0x0A, 0x90, 0xBD, 0x80, 0x6C, 
    0xA4, 0xFD, 0x0B, 0x50, 0xD4, 0x1C, 0x0A, 0x84, 0x0A, 0xA0, 0xAE, 0x39, 0x14, 0x08, 0x15, 0x40, 
    0x5D, 0x73, 0x28, 0x10, 0x26, 0x20, 0x88, 0x9A, 0x43, 0x81, 0xB0, 0x8F, 0x60, 0x10, 0x35, 0x87, 
    0x02, 0x61, 0x02, 0x82, 0xA8, 0x39, 0x14, 0x08, 0x13, 0x10, 0x44, 0xCD, 0xA1, 0x40, 0x98, 0x80, 
    0x20, 0x6A, 0x0E, 0x05, 0xC2, 0x04, 0x04, 0x51, 0x73, 0x28, 0x10, 0x26, 0x20, 0x88, 0x9A, 0x43, 
    0x81, 0x30, 0x01, 0x41, 0xD4, 0x1C, 0x0A, 0x84, 0xBE, 0x01, 0xD4, 0x35, 0x87, 0x02, 0x61, 0x17, 
    0xA1, 0x20, 0x6A, 0x0E, 0x05, 0x42, 0x83, 0x08, 0x75, 0xCD, 0xA1, 0x20, 0x2C, 0x42, 0xB2, 0x17, 
    0x90, 0x4D, 0x28, 0x40, 0xF6, 0x02, 0xB2, 0xF9, 0xF5, 0xBF, 0x80, 0x2A, 0x25, 0x87, 0x0A, 0x5F, 
    0x02, 0x54, 0x2C, 0x39, 0x54, 0xF8, 0x12, 0xA0, 0x62, 0xC9, 0xA1, 0x82, 0x2B, 0x40, 0xD5, 0x92, 
    0x43, 0x05, 0xF7, 0x23, 0xA8, 0x6A, 0xC9, 0xA1, 0x82, 0x2B, 0x40, 0xD5, 0x92, 0x43, 0x05, 0x57, 
    0x80, 0xAA, 0x25, 0x87, 0x0A, 0xAE, 0x00, 0x55, 0x4B, 0x0E, 0x15, 0x5C, 0x01, 0xAA, 0x96, 0x1C, 
    0x2A, 0xB8, 0x9B, 0xAA, 0x5A, 0x72, 0xA8, 0xE0, 0x9E, 0x4C, 0xD5, 0x92, 0x43, 0x85, 0xAF, 0x37, 
    0x40, 0xC5, 0x92, 0x43, 0x05, 0xF7, 0x22, 0xA4, 0x6A, 0xC9, 0xA1, 0xC2, 0x57, 0x10, 0x51, 0xB1, 
    0xE4, 0x50, 0x11, 0x16, 0x21, 0xD9, 0x0B, 0xC8, 0x26, 0x14, 0x20, 0x7B, 0x01, 0xD9, 0x84, 0x02, 
    0x64, 0x2F, 0x20, 0x9B, 0x50, 0x80, 0xEC, 0x05, 0x64, 0xF3, 0x07, 0xB3, 0x5F, 0x07, 0x8C, 0xC6, 
    0x6F, 0xD9, 0x54, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82, 
};
       
        const static uint8_t data4[690] = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0xAA, 0x69, 0x71, 
    0xDE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x13, 0x00, 0x00, 0x0B, 
    0x13, 0x01, 0x00, 0x9A, 0x9C, 0x18, 0x00, 0x00, 0x02, 0x64, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 
    0xED, 0x9A, 0xC1, 0xEA, 0x29, 0x61, 0x18, 0x87, 0x7F, 0x63, 0x46, 0x0D, 0x45, 0x16, 0x76, 0x44, 
    0x36, 0x93, 0xAD, 0x8C, 0x1B, 0x90, 0x2C, 0x29, 0xF7, 0xA0, 0xDC, 0x85, 0x73, 0x0F, 0x96, 0x72, 
    0x0B, 0x92, 0xA5, 0xDC, 0x80, 0x8C, 0x6C, 0x65, 0x23, 0x49, 0x49, 0x0A, 0x4D, 0x0D, 0x8B, 0x31, 
    0x73, 0x16, 0xA7, 0x7F, 0x67, 0xF1, 0xAF, 0xE3, 0x75, 0xF2, 0x9D, 0xB7, 0x8E, 0xF7, 0x59, 0x7F, 
    0xF3, 0xCD, 0x33, 0x4F, 0x4C, 0xD3, 0xD7, 0xAB, 0x05, 0x41, 0x10, 0xE2, 0x83, 0x89, 0x70, 0x0B, 
    0x70, 0x23, 0x01, 0xB8, 0x05, 0xB8, 0x91, 0x00, 0xDC, 0x02, 0xDC, 0x7C, 0x7C, 0x00, 0xE3, 0x6F, 
    0x2E, 0x7A, 0x3C, 0x1E, 0xF0, 0x3C, 0x0F, 0x41, 0x10, 0xC0, 0x30, 0x0C, 0x98, 0xA6, 0x09, 0x5D, 
    0xD7, 0xDF, 0xED, 0xF6, 0x4F, 0x1C, 0xC8, 0x01, 0xC2, 0x30, 0x84, 0xE7, 0x79, 0x58, 0xAD, 0x56, 
    0x58, 0x2C, 0x16, 0xD8, 0x6E, 0xB7, 0xF0, 0x7D, 0x1F, 0xB1, 0x58, 0x0C, 0x85, 0x42, 0x01, 0xB6, 
    0x6D, 0xC3, 0xB2, 0x2C, 0x44, 0xA3, 0xD1, 0x97, 0x25, 0x38, 0x1D, 0xC8, 0x01, 0xCE, 0xE7, 0x33, 
    0xC6, 0xE3, 0x31, 0x86, 0xC3, 0x21, 0xD6, 0xEB, 0x35, 0x6E, 0xB7, 0x1B, 0xC2, 0x30, 0x84, 0xA6, 
    0x69, 0x48, 0x24, 0x12, 0x28, 0x16, 0x8B, 0x68, 0xB7, 0xDB, 0xA8, 0x56, 0xAB, 0xCA, 0x22, 0xA8, 
    0x70, 0x20, 0x05, 0xF0, 0x3C, 0x0F, 0xA3, 0xD1, 0x08, 0xBD, 0x5E, 0x0F, 0xA7, 0xD3, 0x09, 0x41, 
    0x10, 0x7C, 0x13, 0x9B, 0xCD, 0x66, 0xB8, 0x5E, 0xAF, 0x00, 0xA0, 0x24, 0x82, 0x2A, 0x07, 0xD2, 
    0x4B, 0xD0, 0x71, 0x1C, 0x0C, 0x06, 0x03, 0x1C, 0x8F, 0xC7, 0x6F, 0x37, 0xFE, 0x22, 0x08, 0x02, 
    0xAC, 0x56, 0x2B, 0xF4, 0xFB, 0x7D, 0xAC, 0xD7, 0x6B, 0xCA, 0xB6, 0x2F, 0xA1, 0xCA, 0x81, 0x14, 
    0x60, 0x32, 0x99, 0x60, 0xB7, 0xDB, 0x3D, 0x5D, 0xF7, 0x25, 0xE0, 0x38, 0x0E, 0x1E, 0x8F, 0x07, 
    0x49, 0x80, 0x8A, 0x2A, 0x07, 0x52, 0x80, 0xE5, 0x72, 0x49, 0x7E, 0x20, 0xD7, 0x75, 0xB1, 0xD9, 
    0x6C, 0x70, 0xBF, 0xDF, 0x49, 0xEB, 0xA9, 0xA8, 0x72, 0x20, 0x05, 0xD8, 0xEF, 0xF7, 0xA4, 0x1B, 
    0x03, 0xBF, 0xDE, 0xD4, 0xB7, 0xDB, 0x0D, 0xBE, 0xEF, 0x93, 0xAF, 0xE1, 0x74, 0x20, 0x05, 0x48, 
    0xA5, 0x52, 0xE4, 0x9B, 0x6B, 0x9A, 0x06, 0xC3, 0x30, 0x10, 0x89, 0xBC, 0xF7, 0x1B, 0x4B, 0x95, 
    0x03, 0xC9, 0xB2, 0x52, 0xA9, 0x90, 0x1F, 0x28, 0x16, 0x8B, 0x21, 0x9F, 0xCF, 0x23, 0x1E, 0x8F, 
    0x93, 0xD6, 0x53, 0x51, 0xE5, 0x40, 0xDA, 0xB1, 0x56, 0xAB, 0x21, 0x9B, 0xCD, 0x3E, 0xDF, 0x2C, 
    0x12, 0x81, 0x65, 0x59, 0x28, 0x97, 0xCB, 0x6F, 0xFF, 0x32, 0x54, 0xE5, 0x40, 0xFE, 0x05, 0x34, 
    0x1A, 0x0D, 0x24, 0x12, 0x89, 0x3F, 0xAE, 0x4B, 0xA7, 0xD3, 0x68, 0xB5, 0x5A, 0x28, 0x16, 0x8B, 
    0x94, 0x6D, 0x5F, 0x42, 0x95, 0x83, 0xDE, 0xED, 0x76, 0x7F, 0x3C, 0x5B, 0x64, 0x9A, 0x26, 0x72, 
    0xB9, 0x1C, 0x74, 0x5D, 0xC7, 0xE1, 0x70, 0x80, 0xEB, 0xBA, 0x08, 0xC3, 0xDF, 0x27, 0x69, 0xBA, 
    0xAE, 0x23, 0x9F, 0xCF, 0xA3, 0xD3, 0xE9, 0xA0, 0xD9, 0x6C, 0x22, 0x99, 0x4C, 0x42, 0xD3, 0x34, 
    0x92, 0x00, 0x15, 0x55, 0x0E, 0x1A, 0xF5, 0x4C, 0x30, 0x0C, 0x43, 0x9C, 0xCF, 0x67, 0xCC, 0xE7, 
    0x73, 0x4C, 0xA7, 0x53, 0xCC, 0xE7, 0x73, 0x5C, 0x2E, 0x17, 0x64, 0x32, 0x19, 0x94, 0x4A, 0x25, 
    0xD4, 0xEB, 0x75, 0xD8, 0xB6, 0xFD, 0xF6, 0xFF, 0xBE, 0x6A, 0x07, 0x72, 0x80, 0xFF, 0x95, 0x8F, 
    0x3F, 0x0F, 0x90, 0x00, 0xDC, 0x02, 0xDC, 0x48, 0x00, 0x6E, 0x01, 0x6E, 0x24, 0x00, 0xB7, 0x00, 
    0x37, 0x12, 0x80, 0x5B, 0x80, 0x1B, 0x09, 0xC0, 0x2D, 0xC0, 0x8D, 0x04, 0xE0, 0x16, 0xE0, 0x46, 
    0x02, 0x70, 0x0B, 0x70, 0x23, 0x01, 0xB8, 0x05, 0xB8, 0x91, 0x00, 0xDC, 0x02, 0xDC, 0xC8, 0x84, 
    0x08, 0x75, 0xA1, 0x4C, 0x88, 0xC8, 0x84, 0x88, 0x4C, 0x88, 0xC8, 0x84, 0xC8, 0x33, 0x64, 0x42, 
    0x04, 0x32, 0x21, 0x22, 0x13, 0x22, 0x32, 0x21, 0x22, 0x13, 0x22, 0x32, 0x21, 0x22, 0x13, 0x22, 
    0x32, 0x21, 0xA2, 0x08, 0x99, 0x10, 0x51, 0xC0, 0xC7, 0x9F, 0x07, 0x48, 0x00, 0x6E, 0x01, 0x6E, 
    0x24, 0x00, 0xB7, 0x00, 0x37, 0x12, 0x80, 0x5B, 0x80, 0x9B, 0x8F, 0x0F, 0xF0, 0x13, 0x61, 0xFC, 
    0xA8, 0x03, 0xB9, 0xE3, 0x02, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 
    0x60, 0x82, 
};
        
        const static uint8_t data5[803] = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0xAA, 0x69, 0x71, 
    0xDE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x13, 0x00, 0x00, 0x0B, 
    0x13, 0x01, 0x00, 0x9A, 0x9C, 0x18, 0x00, 0x00, 0x02, 0xD5, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 
    0xED, 0x9A, 0xCD, 0x4A, 0xE3, 0x50, 0x18, 0x86, 0xDF, 0xF4, 0x44, 0x48, 0x85, 0x96, 0x0A, 0xEE, 
    0xB4, 0x0D, 0x6E, 0x42, 0xB6, 0xC5, 0x7A, 0x03, 0x22, 0x2E, 0x23, 0xB8, 0x74, 0x5B, 0x0A, 0xBD, 
    0x0B, 0xE7, 0x1E, 0x5C, 0x4A, 0x6F, 0xA1, 0x94, 0x2C, 0x8B, 0x37, 0x50, 0x52, 0xE9, 0x36, 0x64, 
    0x23, 0xA2, 0x82, 0x88, 0x50, 0x25, 0x90, 0xB8, 0x68, 0x92, 0x59, 0x0C, 0x65, 0x18, 0x34, 0xE3, 
    0xD7, 0xA1, 0xE7, 0x87, 0xE9, 0x79, 0xD6, 0x27, 0xE7, 0x3C, 0x79, 0x49, 0x43, 0xFA, 0xF2, 0x19, 
    0x79, 0x9E, 0x17, 0xD8, 0x60, 0x2A, 0xB2, 0x05, 0x64, 0xA3, 0x03, 0x90, 0x2D, 0x20, 0x1B, 0x1D, 
    0x80, 0x6C, 0x01, 0xD9, 0x6C, 0x7C, 0x00, 0xE6, 0xBF, 0x5C, 0x94, 0x65, 0x19, 0x92, 0x24, 0x41, 
    0x9E, 0xE7, 0x30, 0x4D, 0x13, 0x96, 0x65, 0x81, 0x31, 0xB6, 0x6E, 0x37, 0x21, 0x0E, 0xE4, 0x00, 
    0x8A, 0xA2, 0x40, 0x92, 0x24, 0x08, 0xC3, 0x10, 0xB7, 0xB7, 0xB7, 0xB8, 0xBF, 0xBF, 0xC7, 0x62, 
    0xB1, 0x40, 0xB5, 0x5A, 0xC5, 0xC1, 0xC1, 0x01, 0x3A, 0x9D, 0x0E, 0x1C, 0xC7, 0xC1, 0xD6, 0xD6, 
    0xD6, 0xCA, 0x12, 0x32, 0x1D, 0xC8, 0x01, 0xCC, 0xE7, 0x73, 0xF8, 0xBE, 0x8F, 0xE1, 0x70, 0x88, 
    0x28, 0x8A, 0x90, 0xA6, 0x29, 0x8A, 0xA2, 0x80, 0x61, 0x18, 0xA8, 0xD5, 0x6A, 0x70, 0x5D, 0x17, 
    0xBD, 0x5E, 0x0F, 0xC7, 0xC7, 0xC7, 0xDC, 0x42, 0xE0, 0xE1, 0x40, 0x0A, 0x20, 0x49, 0x12, 0x8C, 
    0x46, 0x23, 0x5C, 0x5D, 0x5D, 0xE1, 0xF5, 0xF5, 0x15, 0x79, 0x9E, 0x7F, 0x12, 0x9B, 0x4C, 0x26, 
    0x78, 0x7F, 0x7F, 0x07, 0x00, 0x2E, 0x21, 0xF0, 0x72, 0x20, 0xBD, 0x04, 0xA7, 0xD3, 0x29, 0x06, 
    0x83, 0x01, 0x5E, 0x5E, 0x5E, 0x3E, 0x1D, 0xBC, 0x24, 0xCF, 0x73, 0x84, 0x61, 0x88, 0xEB, 0xEB, 
    0x6B, 0x44, 0x51, 0x44, 0xD9, 0x76, 0x25, 0x78, 0x39, 0x90, 0x02, 0x18, 0x8F, 0xC7, 0x78, 0x78, 
    0x78, 0xF8, 0x76, 0xDD, 0x52, 0x60, 0x3A, 0x9D, 0x22, 0xCB, 0x32, 0x92, 0x00, 0x15, 0x5E, 0x0E, 
    0xA4, 0x00, 0x66, 0xB3, 0x19, 0xF9, 0x86, 0xE2, 0x38, 0xC6, 0xDD, 0xDD, 0x1D, 0x3E, 0x3E, 0x3E, 
    0x48, 0xEB, 0xA9, 0xF0, 0x72, 0x20, 0x05, 0xF0, 0xF4, 0xF4, 0x44, 0x3A, 0x18, 0xF8, 0xF5, 0xA6, 
    0x4E, 0xD3, 0x14, 0x8B, 0xC5, 0x82, 0x7C, 0x8D, 0x4C, 0x07, 0x52, 0x00, 0x8D, 0x46, 0x83, 0x7C, 
    0xB8, 0x61, 0x18, 0x30, 0x4D, 0x13, 0x95, 0xCA, 0x7A, 0xBF, 0xB1, 0x78, 0x39, 0x90, 0x2C, 0x8F, 
    0x8E, 0x8E, 0xC8, 0x37, 0x54, 0xAD, 0x56, 0x61, 0xDB, 0x36, 0xB6, 0xB7, 0xB7, 0x49, 0xEB, 0xA9, 
    0xF0, 0x72, 0x20, 0xED, 0x78, 0x72, 0x72, 0x82, 0xFD, 0xFD, 0xFD, 0xEF, 0x37, 0xAB, 0x54, 0xE0, 
    0x38, 0x0E, 0x0E, 0x0F, 0x0F, 0xD7, 0xFE, 0x65, 0xC8, 0xCB, 0x81, 0xFC, 0x04, 0x78, 0x9E, 0x87, 
    0x5A, 0xAD, 0xF6, 0xD7, 0x75, 0xBB, 0xBB, 0xBB, 0x38, 0x3F, 0x3F, 0x87, 0xEB, 0xBA, 0x94, 0x6D, 
    0x57, 0x82, 0x97, 0x03, 0xBB, 0xBC, 0xBC, 0xFC, 0xF1, 0xDD, 0x22, 0xCB, 0xB2, 0xD0, 0x6A, 0xB5, 
    0xC0, 0x18, 0xC3, 0xF3, 0xF3, 0x33, 0xE2, 0x38, 0x46, 0x51, 0xFC, 0x6E, 0xD2, 0x18, 0x63, 0xB0, 
    0x6D, 0x1B, 0xFD, 0x7E, 0x1F, 0x67, 0x67, 0x67, 0xA8, 0xD7, 0xEB, 0x30, 0x0C, 0x83, 0x24, 0x40, 
    0x85, 0x97, 0x83, 0x41, 0xED, 0x04, 0x8B, 0xA2, 0xC0, 0x7C, 0x3E, 0x47, 0x10, 0x04, 0xB8, 0xB9, 
    0xB9, 0x41, 0x10, 0x04, 0x78, 0x7B, 0x7B, 0xC3, 0xDE, 0xDE, 0x1E, 0xDA, 0xED, 0x36, 0x4E, 0x4F, 
    0x4F, 0xD1, 0xE9, 0x74, 0xD6, 0xFE, 0xDB, 0xE7, 0xED, 0x40, 0x0E, 0xE0, 0x7F, 0x45, 0xF7, 0x01, 
    0x32, 0x0E, 0x55, 0xA1, 0x4F, 0x58, 0x22, 0x2C, 0x00, 0x15, 0xFA, 0x84, 0xAF, 0x10, 0x16, 0x80, 
    0x0A, 0x7D, 0xC2, 0x57, 0x08, 0x09, 0x40, 0x85, 0x3E, 0xA1, 0x0C, 0x21, 0x2F, 0x41, 0x15, 0xFA, 
    0x84, 0x32, 0x84, 0x04, 0xA0, 0x42, 0x9F, 0x50, 0x86, 0x90, 0x00, 0x54, 0xE8, 0x13, 0xCA, 0x10, 
    0x12, 0x80, 0x0A, 0x7D, 0x42, 0x19, 0x42, 0x02, 0x50, 0xA1, 0x4F, 0x28, 0x43, 0xC8, 0x29, 0x2A, 
    0xF4, 0x09, 0x65, 0x08, 0x09, 0x40, 0x85, 0x3E, 0xA1, 0xF4, 0x4C, 0x11, 0x87, 0xA8, 0xD0, 0x27, 
    0x94, 0x21, 0xE4, 0x43, 0x68, 0x67, 0x67, 0x07, 0x17, 0x17, 0x17, 0x00, 0x00, 0xDF, 0xF7, 0xF1, 
    0xF8, 0xF8, 0xF8, 0xC7, 0xF7, 0x00, 0x63, 0x0C, 0xCD, 0x66, 0x13, 0xDD, 0x6E, 0x17, 0x9E, 0xE7, 
    0x09, 0x7B, 0xFC, 0x01, 0x81, 0x7F, 0x87, 0x55, 0xE8, 0x13, 0xBE, 0x42, 0xF7, 0x01, 0xB2, 0x05, 
    0x64, 0xA3, 0x03, 0x90, 0x2D, 0x20, 0x1B, 0x3D, 0x21, 0x42, 0x5D, 0xA8, 0x42, 0xA3, 0xA3, 0x27, 
    0x44, 0xF4, 0x84, 0x88, 0x9E, 0x10, 0xD1, 0x13, 0x22, 0xEB, 0x76, 0xD0, 0x13, 0x22, 0x94, 0x0D, 
    0x55, 0x68, 0x74, 0xF4, 0x84, 0x88, 0x9E, 0x10, 0xD1, 0x13, 0x22, 0x7A, 0x42, 0x44, 0x4F, 0x88, 
    0xE8, 0x09, 0x11, 0x3D, 0x21, 0xB2, 0x76, 0x36, 0xBE, 0x0F, 0xD0, 0x01, 0xC8, 0x16, 0x90, 0x8D, 
    0x0E, 0x40, 0xB6, 0x80, 0x6C, 0x74, 0x00, 0xB2, 0x05, 0x64, 0xB3, 0xF1, 0x01, 0xFC, 0x04, 0x28, 
    0x4C, 0x53, 0xB9, 0x87, 0x06, 0xC0, 0x5B, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 
    0x42, 0x60, 0x82, 
};
        
        const static uint8_t data6[681] = {
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0xAA, 0x69, 0x71, 
    0xDE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x13, 0x00, 0x00, 0x0B, 
    0x13, 0x01, 0x00, 0x9A, 0x9C, 0x18, 0x00, 0x00, 0x02, 0x5B, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 
    0xED, 0x98, 0x31, 0xAA, 0xEA, 0x40, 0x18, 0x85, 0x4F, 0x4C, 0x84, 0x44, 0x50, 0x2C, 0xEC, 0xBC, 
    0x28, 0x36, 0x21, 0xAD, 0x18, 0x37, 0x20, 0x62, 0xA9, 0xE0, 0x1E, 0x04, 0x77, 0xE1, 0xDB, 0x83, 
    0xA5, 0xB8, 0x05, 0x11, 0x4B, 0x71, 0x03, 0xA2, 0x62, 0x2B, 0x36, 0x22, 0x22, 0x88, 0x08, 0x2A, 
    0x81, 0x68, 0x91, 0xCC, 0xBC, 0xE2, 0x71, 0x79, 0xC5, 0x85, 0xE7, 0xCF, 0xC5, 0xDC, 0x81, 0x97, 
    0xFF, 0xD4, 0xFF, 0xFC, 0xE7, 0x70, 0x48, 0x86, 0xE1, 0xD3, 0x84, 0x10, 0x12, 0x31, 0x56, 0x42, 
    0x75, 0x00, 0xD5, 0xE2, 0x02, 0x54, 0x07, 0x50, 0x2D, 0xE3, 0x3B, 0x87, 0xC2, 0x30, 0x84, 0xEF, 
    0xFB, 0x10, 0x42, 0xC0, 0x30, 0x0C, 0x98, 0xA6, 0x09, 0x5D, 0xD7, 0xDF, 0x9D, 0xED, 0x47, 0xFC, 
    0xC9, 0x05, 0x48, 0x29, 0xE1, 0xFB, 0x3E, 0x36, 0x9B, 0x0D, 0x56, 0xAB, 0x15, 0xF6, 0xFB, 0x3D, 
    0x82, 0x20, 0x80, 0x65, 0x59, 0x28, 0x95, 0x4A, 0x70, 0x5D, 0x17, 0xB6, 0x6D, 0x23, 0x99, 0x4C, 
    0x7E, 0x2B, 0x88, 0x2A, 0x7F, 0x72, 0x01, 0xD7, 0xEB, 0x15, 0x93, 0xC9, 0x04, 0xA3, 0xD1, 0x08, 
    0xDB, 0xED, 0x16, 0x8F, 0xC7, 0x03, 0x52, 0x4A, 0x68, 0x9A, 0x86, 0x74, 0x3A, 0x0D, 0xC7, 0x71, 
    0xD0, 0xE9, 0x74, 0x50, 0xAB, 0xD5, 0x22, 0x29, 0x21, 0x2A, 0x7F, 0x52, 0x01, 0xBE, 0xEF, 0x63, 
    0x3C, 0x1E, 0xA3, 0xDF, 0xEF, 0xE3, 0x72, 0xB9, 0x40, 0x08, 0xF1, 0x25, 0xDC, 0x7C, 0x3E, 0xC7, 
    0xFD, 0x7E, 0x07, 0x80, 0xB7, 0x97, 0x10, 0xA5, 0x3F, 0xE9, 0x12, 0x5C, 0x2E, 0x97, 0x18, 0x0E, 
    0x87, 0x38, 0x9F, 0xCF, 0x5F, 0xCC, 0x3F, 0x25, 0x84, 0xC0, 0x66, 0xB3, 0xC1, 0x60, 0x30, 0xC0, 
    0x76, 0xBB, 0x25, 0x99, 0x53, 0x15, 0xA5, 0x3F, 0xA9, 0x80, 0xE9, 0x74, 0x8A, 0xC3, 0xE1, 0xF0, 
    0x72, 0xEE, 0x33, 0xC4, 0x72, 0xB9, 0x44, 0x18, 0x86, 0xE4, 0x10, 0x2A, 0xFD, 0x49, 0x05, 0xAC, 
    0xD7, 0x6B, 0xF2, 0x42, 0xCF, 0xF3, 0xB0, 0xDB, 0xED, 0xF0, 0x7C, 0x3E, 0x49, 0xF3, 0xAA, 0xFD, 
    0x49, 0x05, 0x1C, 0x8F, 0x47, 0xD2, 0x32, 0xE0, 0xCF, 0x6D, 0xFD, 0x78, 0x3C, 0x10, 0x04, 0x01, 
    0xF9, 0x8C, 0x4A, 0x7F, 0x52, 0x01, 0xD9, 0x6C, 0x96, 0x1C, 0x40, 0xD3, 0x34, 0x18, 0x86, 0x81, 
    0x44, 0xE2, 0x7D, 0x6F, 0xAC, 0x28, 0xFD, 0x49, 0x53, 0xD5, 0x6A, 0x95, 0xBC, 0xD0, 0xB2, 0x2C, 
    0x14, 0x8B, 0x45, 0xA4, 0x52, 0x29, 0xD2, 0xBC, 0x6A, 0x7F, 0xD2, 0xD6, 0x7A, 0xBD, 0x8E, 0x8F, 
    0x8F, 0x8F, 0xD7, 0xCB, 0x12, 0x09, 0xD8, 0xB6, 0x8D, 0x4A, 0xA5, 0xF2, 0xD6, 0x97, 0x61, 0x94, 
    0xFE, 0xE4, 0x2F, 0xA0, 0xD9, 0x6C, 0x22, 0x9D, 0x4E, 0xFF, 0x73, 0x2E, 0x97, 0xCB, 0xA1, 0xDD, 
    0x6E, 0xC3, 0x71, 0x1C, 0x92, 0x39, 0x55, 0x51, 0xFA, 0xEB, 0xBD, 0x5E, 0xEF, 0xD7, 0xAB, 0x21, 
    0xD3, 0x34, 0x51, 0x28, 0x14, 0xA0, 0xEB, 0x3A, 0x4E, 0xA7, 0x13, 0x3C, 0xCF, 0x83, 0x94, 0x7F, 
    0x31, 0x82, 0xAE, 0xEB, 0x28, 0x16, 0x8B, 0xE8, 0x76, 0xBB, 0x68, 0xB5, 0x5A, 0xC8, 0x64, 0x32, 
    0xD0, 0x34, 0x8D, 0x1C, 0x42, 0xA5, 0xBF, 0x46, 0x05, 0x22, 0x52, 0x4A, 0x5C, 0xAF, 0x57, 0x2C, 
    0x16, 0x0B, 0xCC, 0x66, 0x33, 0x2C, 0x16, 0x0B, 0xDC, 0x6E, 0x37, 0xE4, 0xF3, 0x79, 0x94, 0xCB, 
    0x65, 0x34, 0x1A, 0x0D, 0xB8, 0xAE, 0xFB, 0xD6, 0x7F, 0xFF, 0x27, 0xFC, 0xC9, 0x05, 0xFC, 0xAF, 
    0x8A, 0x3D, 0x0F, 0xE0, 0x02, 0x54, 0x07, 0x50, 0x2D, 0x2E, 0x40, 0x75, 0x00, 0xD5, 0x62, 0x26, 
    0x48, 0x1D, 0x64, 0x26, 0xC8, 0x4C, 0x90, 0x99, 0x20, 0x33, 0xC1, 0x57, 0x62, 0x26, 0x08, 0x66, 
    0x82, 0xCC, 0x04, 0x99, 0x09, 0x32, 0x13, 0x64, 0x26, 0xC8, 0x4C, 0x90, 0x99, 0x60, 0x04, 0x62, 
    0x26, 0x18, 0x91, 0x62, 0xCF, 0x03, 0xB8, 0x00, 0xD5, 0x01, 0x54, 0x8B, 0x0B, 0x50, 0x1D, 0x40, 
    0xB5, 0x62, 0x5F, 0x00, 0x43, 0x51, 0xEA, 0x20, 0x43, 0x51, 0x86, 0xA2, 0x0C, 0x45, 0x19, 0x8A, 
    0xBE, 0x12, 0x43, 0x51, 0x30, 0x14, 0x65, 0x28, 0xCA, 0x50, 0x94, 0xA1, 0x28, 0x43, 0x51, 0x86, 
    0xA2, 0x0C, 0x45, 0x23, 0x10, 0x43, 0xD1, 0x88, 0x14, 0x7B, 0x1E, 0xC0, 0x05, 0xA8, 0x0E, 0xA0, 
    0x5A, 0xB1, 0x2F, 0xE0, 0x37, 0x5C, 0x1F, 0xF9, 0xC8, 0x38, 0x08, 0xA4, 0x8D, 0x00, 0x00, 0x00, 
    0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82, 
};
        texes[0] = ReadImage(9, (DWORD)g_pd3dDevice, "d1.png", (LPCSTR)data1, sizeof(data1));
        texes[1] = ReadImage(9, (DWORD)g_pd3dDevice, "d2.png", (LPCSTR)data2, sizeof(data2));
        texes[2] = ReadImage(9, (DWORD)g_pd3dDevice, "d3.png", (LPCSTR)data3, sizeof(data3));
        texes[3] = ReadImage(9, (DWORD)g_pd3dDevice, "d4.png", (LPCSTR)data4, sizeof(data4));
        texes[4] = ReadImage(9, (DWORD)g_pd3dDevice, "d5.png", (LPCSTR)data5, sizeof(data5));
        texes[5] = ReadImage(9, (DWORD)g_pd3dDevice, "d6.png", (LPCSTR)data6, sizeof(data6));
    }
  
    bool GuiUpdate()
    {
        bool result = true;
        if (ImGui::Button(S(THPRAC_BACK))) {
            result = false;
        }
        ImGui::SameLine();
        GuiCenteredText(S(THPRAC_TOOLS_DICE));
        ImGui::Separator();

        if (ImGui::Button(S(THPRAC_TOOLS_DICE_DROP), ImVec2(160.0f,0.0f))){
            for (auto& d : dices)
            {
                d.dice.Drop();
                d.is_playing = true;
                d.t = 0.0f;
            }
        }

        bool is_all_playing = false;
        for (auto& d : dices) {
            is_all_playing |= d.is_playing;
        }
        if (!is_all_playing)
        {
            static int n_dice = 1;
            ImGui::SameLine();
            ImGui::SetNextItemWidth(240.0f);
            if (ImGui::SliderInt(S(THPRAC_TOOLS_DICE_NUM), &n_dice, 1, max_dice)) {
                if (n_dice > max_dice)
                    n_dice = max_dice;
                else if (n_dice<=0)
                    n_dice = 1;
                if (n_dice > dices.size())
                {
                    int sz = dices.size();
                    for (int i = 0; i < n_dice - sz;i++)
                        dices.push_back({ Dice(), false, 0.0f });
                } else if (n_dice < dices.size()) {
                    dices.resize(n_dice);
                }
            }
        }
        for (auto& d : dices)
        {
            if (d.is_playing) {
                d.t += 0.008f;
                if (d.t >= 1.0f) {
                    d.t = 1.0f;
                    d.is_playing = false;
                }
                d.dice.Update(d.t);
            }
        }
        
        ImVec2 p0 = ImGui::GetCursorScreenPos();
        ImVec2 csz = ImGui::GetContentRegionAvail();
        if (csz.y < 0)
            csz.y = 0;
        ImVec2 p1 = { p0.x + csz.x, p0.y + csz.y };

        ImDrawList* p = ImGui::GetWindowDrawList();
        p1 = { p0.x + csz.x, p0.y + csz.y };

        auto CvtPts = [](ImVec2 p, ImVec2 p1, ImVec2 p2) -> ImVec2 {
            return { p.x * (p2.x - p1.x) + p1.x, p.y * (p2.y - p1.y) + p1.y };
        };

        static ImVec4 colors_f[6] = { ImVec4(0, 0, 0, 0) };
        static UINT32 colors[6];
        if (colors_f[0].x == 0) {
            float s = 0.5f;
            float v = 0.9f;
            ImGui::ColorConvertHSVtoRGB(1, 0.0f, v, colors_f[0].x, colors_f[0].y, colors_f[0].z);
            ImGui::ColorConvertHSVtoRGB(240.0f / 360.0f, s, v, colors_f[1].x, colors_f[1].y, colors_f[1].z);
            ImGui::ColorConvertHSVtoRGB(0.0f / 360.0f, s, v, colors_f[2].x, colors_f[2].y, colors_f[2].z);
            ImGui::ColorConvertHSVtoRGB(30.0f / 360.0f, s, v, colors_f[3].x, colors_f[3].y, colors_f[3].z);
            ImGui::ColorConvertHSVtoRGB(120.0f / 360.0f, s, v, colors_f[4].x, colors_f[4].y, colors_f[4].z);
            ImGui::ColorConvertHSVtoRGB(60.0f / 360.0f, s, v, colors_f[5].x, colors_f[5].y, colors_f[5].z);
            for (int i = 0; i < 6; i++) {
                colors_f[i].w = 1.0f;
                colors[i] = ImGui::ColorConvertFloat4ToU32(colors_f[i]);
            }
        }
        int cutX[] = { 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4 };
        int cutY[] = { 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 };
        if (csz.y > 0.0f) {
            p->AddRectFilled(p0, p1, IM_COL32(50, 50, 50, 100));
            p->AddRect(p0, p1, IM_COL32(255, 255, 255, 100));
            p->PushClipRect(p0, p1);

            p1.y = p1.y - ImGui::GetTextLineHeight() * 2.0f;
            int cur_cutx = cutX[dices.size()];
            int cur_cuty = cutY[dices.size()];
            float width2 = (p1.x - p0.x) / cur_cutx;
            float height = (p1.y - p0.y) / cur_cuty;
            float width = std::min(width, height);
            height = width;

            for (int i = 0; i < dices.size();i++)  {
                auto& d = dices[i];

                int idx_x = i % cur_cutx;
                int idx_y = i / cur_cutx;
                ImVec2 cur_p0 = { p0.x + width2 * idx_x, p0.y + height * idx_y };
                ImVec2 cur_p1 = { cur_p0.x + width, cur_p0.y + height};

                float hover_sz = 0.7f;
                ImVec2 hover_p0 = { cur_p1.x * (1.0f - hover_sz) + cur_p0.x * hover_sz, cur_p1.y * (1.0f - hover_sz) + cur_p0.y * hover_sz };
                ImVec2 hover_p1 = { cur_p1.x * hover_sz + cur_p0.x * (1.0f - hover_sz), cur_p1.y * hover_sz + cur_p0.y * (1.0f - hover_sz) };
                bool is_hovered = false;
                if (ImGui::IsMouseHoveringRect(hover_p0, hover_p1)){
                    is_hovered = true;
                }

                std::vector<ImVec2> points;
                std::vector<int> dice_num;
                d.dice.Render(points, dice_num);
                for (auto& p : points)
                    p = CvtPts(p, cur_p0, cur_p1);

                for (int i = 0; i < points.size(); i += 4) {
                    auto diceidx = dice_num[i / 4] - 1;
                    if (texes[diceidx]) {
                        p->AddImageQuad(texes[diceidx], points[i + 0], points[i + 1], points[i + 2], points[i + 3]);
                    } else {
                        p->AddQuadFilled(points[i + 0], points[i + 1], points[i + 2], points[i + 3], colors[diceidx]);
                    }
                }
                for (int i = 0; i < points.size(); i += 4) {
                    if (is_hovered)
                        p->AddQuad(points[i + 0], points[i + 1], points[i + 2], points[i + 3], IM_COL32(255, 128, 0, 255), 4.0f);
                    else
                        p->AddQuad(points[i + 0], points[i + 1], points[i + 2], points[i + 3], IM_COL32(0, 0, 0, 255), 3.0f);
                }
                p->AddText(ImGui::GetFont(),64.0, { cur_p0.x * 0.5f + cur_p1.x * 0.5f, cur_p1.y - ImGui::GetTextLineHeight() * 1.6f },
                    0xFFFFFFFF, std::format("{}", d.dice.GetResult()).c_str());
                if (is_hovered&& ImGui::IsMouseClicked(ImGuiMouseButton_Left)){
                    dices[i].dice.Drop();
                    dices[i].t = 0;
                    dices[i].is_playing = true;
                }
            }
            p->PopClipRect();
        }
        return result;
    }
};

class THRoll
{
public:
    struct THRollSelection {
        std::string name;
        float weight;
        ImVec4 color;
    };
    float GetRandomFloat(float a=0.0f,float b=1.0f)
    {
        static auto rnd_gen = GetRndGenerator(0.0f,1.0f);
        return rnd_gen()*(b-a)+a;
    }
    float MInterpolation(float t, float a, float b)
    {
        if (t < 0.0f) {
            return a;
        } else if (t < 0.5) {
            float k = (b - a) * 2.0f;
            return k * t * t + a;
        } else if (t < 1.0f) {
            float k = (b - a) * 4.0f;
            t = t - 1.0f;
            return k * t * t * t + b;
        }
        return b;
    };

private:
    std::vector<THRollSelection> selections;
    float weight_sum;
    std::string mRollName;

    bool DrawPie(ImDrawList* p, ImVec2 mid, float radius, float angle1, float angle2, uint32_t col_fill)
    {
        uint32_t col_line = 0xFFFFFFFF;
        bool res = false;
        std::vector<ImVec2> points;
        points.push_back({ cosf(angle1), sinf(angle1) });
        float dangle = std::numbers::pi * 0.005f;
        for (float angle = angle1 + dangle; angle < angle2; angle += dangle)
            points.push_back({ cosf(angle), sinf(angle) });
        points.push_back({ cosf(angle2), sinf(angle2) });

        auto mp = ImGui::GetMousePos();
        if (hypotf(mp.y - mid.y, mp.x - mid.x) < radius) {
            float mangle = atan2(mp.y - mid.y, mp.x - mid.x);
            mangle += (2.0f * std::numbers::pi) * ceilf((angle1 - mangle) / (2.0f * std::numbers::pi));
            res = mangle < angle2;
        }
        uint32_t col_fill2 = 0;
        if (res) {
            radius *= 1.1f;
            ImVec4 color = ImGui::ColorConvertU32ToFloat4(col_fill);
            col_fill2 = ImGui::ColorConvertFloat4ToU32(ImVec4 { color.x * 0.75f,
                                                                color.y * 0.75f,
                                                                color.z * 0.75f,
                                                                color.w });
        }
        
        for (int i = 0; i < points.size() - 1; i++) {
            ImVec2 p2 = { mid.x + points[i].x * radius, mid.y + points[i].y * radius };
            ImVec2 p3 = { mid.x + points[i + 1].x * radius, mid.y + points[i + 1].y * radius };
            p->AddTriangleFilled(mid, p2, p3, res ? col_fill2 : col_fill);
            p->AddTriangle(mid, p2, p3, res ? col_fill2 : col_fill, 1.33f);
            if (res) {
                p->AddLine(p2, p3, col_line, 2.0f);
            }
            
        }
        p->AddLine(mid, { mid.x + points[0].x * radius, mid.y + points[0].y * radius }, col_line, 2.0f);
        if (res) {
            p->AddLine(mid, { mid.x + points[points.size() - 1].x * radius, mid.y + points[points.size() - 1].y * radius }, col_line, 2.0f);
        }
        return res;
    }

    void InitWeight()
    {
        weight_sum = 0.0f;
        for (auto& i : selections)
        {
            weight_sum += i.weight;
        }
    }
    void InitColors(bool rand_color = true)
    {
        if (rand_color) {
            for (int i = 0; i < selections.size(); i++) {
                float r, g, b, h, s, v;
                h = GetRandomFloat();
                s = GetRandomFloat() * 0.4f + 0.6f;
                v = GetRandomFloat() * 0.4f + 0.6f;
                ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b);
                selections[i].color = { r, g, b, 1.0f };
            }
        } else {
            int hi = 0, si = 255, vi = 255;
            for (int i = 0; i < selections.size(); i++) {
                float r, g, b, h, s, v;
                if (selections.size() > 100)
                    hi += 7;
                else if (selections.size() > 50)
                    hi += 19;
                else
                    hi += 41;
                if (hi >= 256) {
                    hi -= 256;
                    si -= 83;
                    if (si <= 64) {
                        si += 191;
                        vi -= 101;
                        if (vi <= 128)
                            vi += 127;
                    }
                }
                hi %= 256;
                h = (float)hi / 255.0f;
                vi %= 256;
                s = (float)vi / 255.0f;
                si %= 256;
                v = (float)si / 255.0f;
                ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b);
                selections[i].color = { r, g, b, 1.0f };
            }
        }
    }

public:
    THRollSelection GetSelection(int idx)
    {
        return selections[idx];
    }

    int NumSelection()
    {
        return selections.size();
    }

    void RemoveSelection(int idx)
    {
        if (idx < selections.size()) {
            selections.erase(selections.begin() + idx);
        }
        InitWeight();
    }

    void InitRoll(std::string rollName, std::vector<THRollSelection> sels, bool reset_color = true, bool rand_color = true)
    {
        selections = sels;
        mRollName = rollName;
        if (reset_color) {
            InitColors(rand_color);
        }
        InitWeight();
    }

    void InitRoll(std::wstring csv_filename, bool rand_color = true)
    {
        std::vector<std::string> mNames = {};
        std::vector<float> mWeights = {};

        std::string rollName = utf16_to_utf8(GetNameFromFullPath(csv_filename).c_str());

        rapidcsv::Document doc(utf16_to_mb(csv_filename.c_str(), CP_ACP), rapidcsv::LabelParams(0, -1));
        mNames = doc.GetColumn<std::string>(0);
        mWeights = doc.GetColumn<float>(1);
        int n = std::min(mNames.size(), mWeights.size());
        std::vector<THRollSelection> selections_csv;
        for (int i = 0; i < n; i++) {
            THRollSelection sel;
            sel.name = mNames[i];
            sel.weight = mWeights[i];
            sel.color = { 1.0f, 1.0f, 1.0f, 1.0f };
            selections_csv.push_back(sel);
        }
        InitRoll(rollName, selections_csv, true, rand_color);
    }

    void InitRoll(std::string rollName,std::vector<std::string> names, bool rand_color = true)
    {
        std::vector <THRollSelection> sels = {};
        for (auto& n : names)
        {
            THRollSelection sel;
            sel.name = n;
            sel.weight = 1.0f;
            sel.color = { 1.0f, 1.0f, 1.0f, 1.0f };
            sels.push_back(sel);
        }
        InitRoll(rollName, sels, true, rand_color);
    }

    THRoll(std::string rollName, std::vector<THRollSelection> sels, bool reset_color = true, bool rand_color = true)
    {
        InitRoll(rollName, sels, reset_color, rand_color);
    }
    THRoll()
    {
        weight_sum = 0.0f;
    }
    THRoll(std::wstring csv_filename, bool rand_color = true)
    {
        InitRoll(csv_filename, rand_color);
    }

    int CalcIdx(float angle)
    {
        angle = -angle;
        angle = angle - floorf(angle / (2.0f * std::numbers::pi)) * 2.0f * std::numbers::pi;
        int idx = -1;
        float res = angle / (2.0f * std::numbers::pi);
        float weight_cur = 0;
        for (int i = 0; i < selections.size(); i++) {
            float weight_next = weight_cur + selections[i].weight;
            if (weight_cur / weight_sum <= res && weight_next / weight_sum > res) {
                idx = i;
                break;
            }
            weight_cur = weight_next;
        }
        return idx;
    }

    void GuiDraw(float& angle,int selection_idx,float height_rem = 0.0f)
    {
        angle = angle - floorf(angle / (2.0f * std::numbers::pi)) * 2.0f * std::numbers::pi;
        {
            ImVec2 p0 = ImGui::GetCursorScreenPos();
            ImVec2 csz = ImGui::GetContentRegionAvail();
            csz.y -= height_rem;
            if (csz.y < 0)
                csz.y = 0;
            ImVec2 cmid = { p0.x + csz.x * 0.5f, p0.y + csz.y * 0.5f };
            ImVec2 p1 = { cmid.x + csz.x * 0.5f, cmid.y + csz.y * 0.5f };
            float hheight = std::min(csz.x, csz.y) * 0.95f * 0.5f;

            ImDrawList* p = ImGui::GetWindowDrawList();
            p->AddRectFilled(p0, p1, IM_COL32(50, 50, 50, 100));
            p->AddRect(p0, p1, IM_COL32(255, 255, 255, 100));
            p->PushClipRect(p0, p1);

            ImVec2 cir_cen = { hheight * 1.1f, cmid.y };
            if (selections.size() > 0 && csz.y > 0.0f) {
                {
                    p->AddCircle(cir_cen, hheight, 0xFFFFFFFF);
                    float pie_angle_start = angle;
                    for (int i = 0; i < selections.size(); i++) {
                        float pie_angle_delta = selections[i].weight / weight_sum * 2.0f * std::numbers::pi;

                        auto col1 = ImGui::ColorConvertFloat4ToU32(selections[i].color);
                        bool hovered = false;
                        if (selection_idx==i)
                            hovered = DrawPie(p, cir_cen, hheight * 1.05f, pie_angle_start, pie_angle_start + pie_angle_delta, col1);
                        else
                            hovered  = DrawPie(p, cir_cen, hheight, pie_angle_start, pie_angle_start + pie_angle_delta, col1);
                        if (hovered)
                            ImGui::SetTooltip("%s", selections[i].name.c_str());
                        pie_angle_start += pie_angle_delta;
                    }
                }
                ImVec2 tri_pos1 = { cir_cen.x + hheight * 0.95f, cir_cen.y };
                ImVec2 tri_pos2 = { cir_cen.x + hheight * 1.45f, cir_cen.y - hheight * 0.05f };
                ImVec2 tri_pos3 = { cir_cen.x + hheight * 1.45f, cir_cen.y + hheight * 0.05f };
                p->AddTriangleFilled(tri_pos1, tri_pos2, tri_pos3, 0xFFFFCCCC);
                p->AddTriangle(tri_pos1, tri_pos2, tri_pos3, 0xFFFFFFFF, 1.5f);
                if (selection_idx >= 0 && selection_idx < selections.size())
                    p->AddText({ cir_cen.x + hheight * 1.5f, cir_cen.y - ImGui::GetTextLineHeight() * 0.5f }, 0xFFFFFFFF, std::format("{}", selections[selection_idx].name).c_str());
                p->PopClipRect();
            }
        }
        return;
    }
};


class THGuiRollAll {
private:
    THRoll mRoll;
    bool mRandColor;

    bool is_rolling;
    float angle_fin;
    float angle_last;
    float time;
    float time_tot;

public:
    THGuiRollAll()
    {
        is_rolling = false;
        angle_fin = 0.0f;
        angle_last = 0.0f;
        mRandColor = false;
        time_tot = 240.0f;
        time = 0.0f;
    }
    
    void LoadRoll()
    {
        std::wstring csv_filename = LauncherWndFileSelect(nullptr, L"csv(*.csv)\0*.csv\0*.*\0\0");
        mRoll.InitRoll(csv_filename, true);
    }
    void LoadRollWaifu()
    {
        mRoll.InitRoll("waifu", waifus, mRandColor);
    }
    bool GuiUpdate()
    {
        bool result = true;
        if (ImGui::Button(S(THPRAC_BACK))) {
            result = false;
        }
        ImGui::SameLine();
        GuiCenteredText(S(THPRAC_TOOLS_ROLLF_FROM_FILE));
        ImGui::Separator();
        if (ImGui::Button(S(THPRAC_TOOLS_ROLLF_CSV)))
            LoadRoll();
        ImGui::SameLine();
        GuiHelpMarker(S(THPRAC_TOOLS_ROLLF_CSV_DESC));
        ImGui::SameLine();
        if (ImGui::Button("waifus"))
            LoadRollWaifu();
        ImGui::SameLine();
        ImGui::Checkbox(S(THPRAC_TOOLS_ROLLF_RANDOM_COLOR), &mRandColor);
        ImGui::SameLine();
        if (ImGui::CollapsingHeader(S(THPRAC_TOOLS_ROLLF_CLPS))){
            if (ImGui::BeginTable("__rolls table",2)) {
                for (int i = 0; i < mRoll.NumSelection(); i++)
                {
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn();
                    ImGui::Text("%s", mRoll.GetSelection(i).name.c_str());
                    ImGui::TableNextColumn();
                    ImGui::Text("%.2f", mRoll.GetSelection(i).weight);
                }
                ImGui::EndTable();
            }
        }
        ImGui::Separator();

        if (ImGui::Button(S(THPRAC_TOOLS_ROLLF_START)) && mRoll.NumSelection() > 0)
        {
            is_rolling = true;
            time = 0;
            angle_last = angle_fin - floorf(angle_fin / (2.0f * std::numbers::pi)) * 2.0f * std::numbers::pi;
            angle_fin = (mRoll.GetRandomFloat() * 2.0f * std::numbers::pi) + 30.0f * std::numbers::pi;
        }
        float angle_cur;
        if (is_rolling) {
            angle_cur = mRoll.MInterpolation(time / (float)time_tot, angle_last, angle_fin);
            if (time < time_tot) {
                time++;
            } else {
                is_rolling = false;
            }
        } else {
            angle_cur = angle_fin;
        }
        int roll_result = mRoll.CalcIdx(angle_cur);
        if (!is_rolling) {
            ImGui::SameLine();
            if (ImGui::Button(S(THPRAC_TOOLS_ROLLF_REMOVE_CUR))){
                mRoll.RemoveSelection(roll_result);
            }
            
        }
        if (!is_rolling) {
            ImGui::SameLine();
            ImGui::Text(S(THPRAC_TOOLS_ROLLF_TIME));
            ImGui::SameLine();
            ImGui::SetNextItemWidth(150.0f);
            if (ImGui::DragFloat("##roll time", &time_tot, 1.0f, 1, 1000))
                time_tot = std::clamp(time_tot, 1.0f, 1000.0f);
        }

        mRoll.GuiDraw(angle_cur, roll_result);
        return result;
    }

private:
};

THGuiTestReactionTest::THGuiTestReactionTest()
{
    QueryPerformanceFrequency(&mTimeFreq);
    mTestState = NOT_BEGIN;
    mTestType = PRESS;
    mTestTime = 5;
    mRndSeedGen = GetRndGenerator(1200u, 2800u);
    // mRndSeedGen = GetRndGenerator(0u, 1u);
    mShowProgressBar = false;
    mCurTest = 0;
}
bool THGuiTestReactionTest::GuiUpdate(bool ingame)
{
    LARGE_INTEGER curTime;
    QueryPerformanceCounter(&curTime);
    Gui::KeyboardInputUpdate(VK_DOWN);
    Gui::KeyboardInputUpdate(VK_UP);
    Gui::KeyboardInputUpdate(VK_RIGHT);
    Gui::KeyboardInputUpdate(VK_LEFT);
    Gui::KeyboardInputUpdate('Z');
    Gui::KeyboardInputUpdate(VK_SHIFT);

    ImVec2 colorBtnSz = ImVec2(ImGui::GetWindowWidth()*0.5f, ImGui::GetTextLineHeight() * 10.0f);
    ImVec2 colorBtnPos = ImVec2(ImGui::GetWindowWidth()*0.25f, ImGui::GetTextLineHeight() * 2.0f);
    DWORD colorBtnFlag = ImGuiColorEditFlags_::ImGuiColorEditFlags_NoTooltip;
    ImVec4 color_BeforeTimeReact = ImVec4(1, 0.2, 0.2, 1);
    ImVec4 color_AfterTimeReact = ImVec4(0, 1, 0.2, 1);
    ImVec4 color_WaitPress = ImVec4(1, 1, 0.2, 1);

    bool isKeyPressed = ImGui::IsKeyDown(37) || ImGui::IsKeyDown(38) || ImGui::IsKeyDown(39) || ImGui::IsKeyDown(40)
        || (GetAsyncKeyState(VK_DOWN) & 0x8000) || (GetAsyncKeyState(VK_UP) & 0x8000) || (GetAsyncKeyState(VK_RIGHT) & 0x8000) || (GetAsyncKeyState(VK_LEFT) & 0x8000);
    if (!ingame){
        if (ImGui::Button(S(THPRAC_BACK))) {
            Reset();
            return false;
        }
    }
    switch (mTestState)
    {
    case NOT_BEGIN:
    {
        if (!ingame) {
            ImGui::SameLine();
            GuiCenteredText(S(THPRAC_TOOLS_REACTION_TEST));
            ImGui::Separator();
        }
    
        ImGui::RadioButton(S(THPRAC_TOOLS_REACTION_TEST_DOWN), (int*)&mTestType, PRESS);
        ImGui::SameLine();
        ImGui::RadioButton(S(THPRAC_TOOLS_REACTION_TEST_UP), (int*)&mTestType, RELEASE);
    
        ImGui::Checkbox(S(THPRAC_TOOLS_REACTION_SHOW_PROC_BAR), &mShowProgressBar);
    
        ImGui::DragInt(S(THPRAC_TOOLS_REACTION_TEST_TIME), &mTestTime, 1.0f, 1, 20);
        ImGui::NewLine();
        if (ImGui::Button(S(THPRAC_TOOLS_REACTION_TEST_BEGIN)) || ImGui::IsKeyPressed('Z') || ImGui::IsKeyPressed(VK_SHIFT)) {
            // in win 7, due to the initialize sequence, QueryPerformanceFrequency might get 0 value at the beginning, 
            // so query it every time before test begin to avoid this problem
            QueryPerformanceFrequency(&mTimeFreq);
            mTestState = WAIT_TIME;
            mCurTest = 1;
            mFrameCount = 0;
            if (mTestType == PRESS) {
                mWaitTime.QuadPart = mRndSeedGen() / 1000.0 * (double)mTimeFreq.QuadPart;
                mPressTime.QuadPart = mWaitTime.QuadPart + curTime.QuadPart;
            }
            mResults = {};
        }
        ImGui::InvisibleButton("inv", colorBtnSz);
    } break;
    
    case TOO_EARLY: {
        ImGui::Text(S(THPRAC_TOOLS_REACTION_TEST_TOO_EARLY));
        if (ImGui::Button(S(THPRAC_TOOLS_REACTION_TEST_NEXT_TEST)) || ImGui::IsKeyPressed('Z') || ImGui::IsKeyPressed(VK_SHIFT)) // press z(90)/shift(16)
        {
            mFrameCount = 0;
            mTestState = WAIT_TIME;
            mWaitTime.QuadPart = mRndSeedGen() / 1000.0 * (double)mTimeFreq.QuadPart;
            mPressTime.QuadPart = mWaitTime.QuadPart + curTime.QuadPart;
        }
        ImGui::InvisibleButton("inv", colorBtnSz);
    } break;
    case SHOW_RES: {
        if (mResults.size() != 0 && mFrameCounts.size() != 0)
        {
            ImGui::Text("%s(%d): %.1f ms (%.1f frame)(framecount: %d)", S(THPRAC_TOOLS_REACTION_TEST_RESULT), mCurTest, mResults[mResults.size() - 1], mResults[mResults.size() - 1] / 16.66667f,(int)mFrameCounts[mFrameCounts.size()-1]);
            if (mCurTest < mTestTime)
                ImGui::InvisibleButton("inv", colorBtnSz);
        }else
            ImGui::Text("%s(%d): ?????", S(THPRAC_TOOLS_REACTION_TEST_RESULT), mCurTest);
        if (mCurTest == mTestTime)
        {
            float avg = 0.0f;
            float maxv = 60.0f;
            float minv = 0.0f;
            float avg_frameCnt = 0.0f;
            float maxfcnt = 10.0f;
            float minfcnt = 0.0f;
            for (auto x : mResults) {
                avg += fabsf(x);
                maxv = std::max(x, maxv);
                minv = std::min(x, minv);
            }
            for (auto x : mFrameCounts) {
                avg_frameCnt += fabsf(x);
                maxfcnt = std::max(x, maxfcnt);
                minfcnt = std::min(x, minfcnt);
            }
            avg /= (float)mTestTime;
            avg_frameCnt /= (float)mTestTime;
            ImGui::Separator();
            ImGui::Text("%s: %s, %s", S(THPRAC_TOOLS_REACTION_MODE), mTestType == PRESS ? S(THPRAC_TOOLS_REACTION_MODE_DOWN) : S(THPRAC_TOOLS_REACTION_MODE_UP), 
                mShowProgressBar ? S(THPRAC_TOOLS_REACTION_MODE_PROGRESSBAR) : S(THPRAC_TOOLS_REACTION_MODE_NORMAL)
            );
            ImGui::Text("%s: %.1f ms (%.1f frame)(framecount: %.1f)", S(THPRAC_TOOLS_REACTION_TEST_RESULT_AVG), avg, avg / 16.66667f, avg_frameCnt);
            
            ImGui::PlotHistogram(S(THPRAC_TOOLS_REACTION_TEST_RESULT), &mResults[0], mTestTime, 0, S(THPRAC_TOOLS_REACTION_TEST_RESULT), minv-10.0f, maxv+20.0f, ImVec2(0, 200.0));
            
            ImGui::PlotHistogram(std::format("{}(framecount)", S(THPRAC_TOOLS_REACTION_TEST_RESULT)).c_str(), &mFrameCounts[0], mTestTime, 0, std::format("{}(framecount)", S(THPRAC_TOOLS_REACTION_TEST_RESULT)).c_str(), minfcnt-1.0f, maxfcnt + 10.0f, ImVec2(0, 200.0));
            if (ImGui::Button(S(THPRAC_TOOLS_REACTION_TEST_NEXT_TEST)) || ImGui::IsKeyPressed('Z') || ImGui::IsKeyPressed(VK_SHIFT)) {
                mTestState = NOT_BEGIN;
            }
        } else {
            if (ImGui::Button(S(THPRAC_TOOLS_REACTION_TEST_NEXT_TEST)) || ImGui::IsKeyPressed('Z') || ImGui::IsKeyPressed(VK_SHIFT)) // press z
            {
                mCurTest++;
                mTestState = WAIT_TIME;
                mFrameCount = 0;
                mWaitTime.QuadPart = mRndSeedGen() / 1000.0 * (double)mTimeFreq.QuadPart;
                mPressTime.QuadPart = mWaitTime.QuadPart + curTime.QuadPart;
            }
        }
    } break;
    
    case REACT_TIME:
    case WAIT_TIME:
    case WAIT_TIME_PRESSED:
    {
        if (mTestType == PRESS)
        {
            if (mTestState == WAIT_TIME && curTime.QuadPart >= mPressTime.QuadPart){
                mTestState = REACT_TIME;
                mFrameCount = 0;
            }
            ImGui::Text("test %d", mCurTest);
            mFrameCount++;
            if (mTestState == WAIT_TIME) {
                if (mShowProgressBar) {
                    ImGui::ProgressBar(std::clamp(std::fabsf(((double)(mPressTime.QuadPart - curTime.QuadPart)) / ((double)mWaitTime.QuadPart)), 0.0f, 1.0f), ImVec2(0, 0), "waiting...");
                }
                ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + colorBtnPos.x, ImGui::GetCursorPosY() + colorBtnPos.y));
                ImGui::ColorButton("color", color_BeforeTimeReact, colorBtnFlag, colorBtnSz);
                if (isKeyPressed){
                    if (!mShowProgressBar){
                        mTestState = TOO_EARLY;
                    } else {
                        // allow negative reaction time
                        auto curTestReactionTimeMs = ((double)(curTime.QuadPart - mPressTime.QuadPart)) / ((double)mTimeFreq.QuadPart) * 1000.0;
                        mResults.push_back(curTestReactionTimeMs);
                        mFrameCounts.push_back(ceil(fabsf(curTestReactionTimeMs))/16.6667f);
                        mTestState = SHOW_RES;
                    }
                }
            } else {
                if (mShowProgressBar) {
                    ImGui::ProgressBar(0.0f, ImVec2(0, 0), "press...");
                }
                ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + colorBtnPos.x, ImGui::GetCursorPosY() + colorBtnPos.y));
                ImGui::ColorButton("color", color_AfterTimeReact, colorBtnFlag, colorBtnSz);
                if (isKeyPressed){
                    auto curTestReactionTimeMs = ((double)(curTime.QuadPart - mPressTime.QuadPart)) / ((double)mTimeFreq.QuadPart) * 1000.0;
                    mResults.push_back(curTestReactionTimeMs);
                    mFrameCounts.push_back(mFrameCount);
                    mTestState = SHOW_RES;
                }
            }
        }else{
            if (mTestState == WAIT_TIME_PRESSED && curTime.QuadPart >= mPressTime.QuadPart) {
                mTestState = REACT_TIME;
                mFrameCount = 0;
            }
            mFrameCount++;
            ImGui::Text("test %d", mCurTest);
            if (mTestState == WAIT_TIME) {
                if (mShowProgressBar) {
                    ImGui::ProgressBar(1.0f, ImVec2(0, 0), "waiting...");
                }
                ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + colorBtnPos.x, ImGui::GetCursorPosY() + colorBtnPos.y));
                ImGui::ColorButton("color", color_WaitPress, colorBtnFlag, colorBtnSz);
                if (isKeyPressed) {
                    mWaitTime.QuadPart = mRndSeedGen() / 1000.0 * (double)mTimeFreq.QuadPart;
                    mPressTime.QuadPart = mWaitTime.QuadPart + curTime.QuadPart;
                    mTestState = WAIT_TIME_PRESSED;
                }
            } else if(mTestState == REACT_TIME){
                if (mShowProgressBar) {
                    ImGui::ProgressBar(0.0f, ImVec2(0, 0), "press...");
                }
                ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + colorBtnPos.x, ImGui::GetCursorPosY() + colorBtnPos.y));
                ImGui::ColorButton("color", color_AfterTimeReact, colorBtnFlag, colorBtnSz);
                if (!isKeyPressed) {
                    auto curTestReactionTimeMs = ((double)(curTime.QuadPart - mPressTime.QuadPart)) / ((double)mTimeFreq.QuadPart) * 1000.0;
                    mResults.push_back(curTestReactionTimeMs);
                    mFrameCounts.push_back(mFrameCount);
                    mTestState = SHOW_RES;
                }
            }
            else if (mTestState == WAIT_TIME_PRESSED){
                if (mShowProgressBar) {
                    ImGui::ProgressBar(std::clamp(std::fabsf(((double)(mPressTime.QuadPart - curTime.QuadPart)) / ((double)mWaitTime.QuadPart)), 0.0f, 1.0f), ImVec2(0, 0), "waiting...");
                }
                ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + colorBtnPos.x, ImGui::GetCursorPosY() + colorBtnPos.y));
                ImGui::ColorButton("color", color_BeforeTimeReact, colorBtnFlag, colorBtnSz);
                if (!isKeyPressed) {
                    if (!mShowProgressBar) {
                        mTestState = TOO_EARLY;
                    } else {
                        auto curTestReactionTimeMs = ((double)(curTime.QuadPart - mPressTime.QuadPart)) / ((double)mTimeFreq.QuadPart) * 1000.0;
                        mResults.push_back(curTestReactionTimeMs);
                        mFrameCounts.push_back(ceil(fabsf(curTestReactionTimeMs)) / 16.6667f);
                        mTestState = SHOW_RES;
                    }
                }
            }
        }
    } 
    break;
    }
    return true;
}

void THGuiTestReactionTest::Reset()
{
    QueryPerformanceFrequency(&mTimeFreq);
    mTestState = NOT_BEGIN;
    mTestType = PRESS;
    mTestTime = 5;
    mRndSeedGen = GetRndGenerator(1200u, 3500u);
    mShowProgressBar = false;
    mCurTest = 0;
    mResults = {};
    mFrameCounts = {};
}


class THGuiRollPlayer {
public:
    THRoll mRoll;

    bool first_roll;
    bool is_rolling;
    float angle_fin;
    float angle_last;
    float time;
    float time_tot;


    THGuiRollPlayer()
    {
        is_rolling = false;
        first_roll = true;
        angle_fin = -0.1f;
        angle_last = -0.1f;
        time_tot = 240.0f;
        time = 0.0f;

        mRndTextGen = GetRndGenerator(1u, 20u);

        for (auto& game : gGameRoll) {
            if (game.playerSelect) {
                mGameOption.push_back(game);
            }
        }
        if (mRndTextGen() == 1) {
            mRollText = S(THPRAC_GAMEROLL_EENY_MEENY);
        } else {
            mRollText = S(THPRAC_GAMEROLL_ROLL);
        }
        SetPlayerOpt();
        UpdateRoll();
    }

    void UpdateRoll()
    {
        std::vector<std::string> names;
        for (auto& player : mPlayerOption) {
            if (player.second) {
                names.push_back(player.first);
            }
        }
        mRoll.InitRoll("rndgame", names, false);
    }

    void SwitchGame(const char* gameStr)
    {
        int i = 0;
        for (auto& game : mGameOption) {
            if (!strcmp(game.name, gameStr)) {
                mGameSelected = i;
                SetPlayerOpt();
            }
            ++i;
        }
        UpdateRoll();
    }
    void SetPlayerOpt()
    {
        mPlayerOption.clear();
        mRollText = S(THPRAC_GAMEROLL_ROLL);
        auto playerStr = S(mGameOption[mGameSelected].shottypes);
        while (playerStr[0] != '\0') {
            mPlayerOption.push_back(std::pair<std::string, bool>(playerStr, true));
            for (; playerStr[0] != '\0'; ++playerStr)
                ;
            ++playerStr;
        }
    }
    bool GuiUpdate()
    {
        bool result = true;
        if (ImGui::Button(S(THPRAC_BACK))) {
            result = false;
        }
        ImGui::SameLine();
        GuiCenteredText(S(THPRAC_TOOLS_RND_PLAYER));
        ImGui::Separator();

        bool changed = false;
        if (ImGui::CollapsingHeader(S(THPRAC_TOOLS_RND_PLAYER))) {

            if (ImGui::BeginCombo(S(THPRAC_TOOLS_RND_PLAYER_GAME), S(mGameOption[mGameSelected].title), 0)) { // The second parameter is the label previewed before opening the combo.
                changed = true;
                for (size_t n = 0; n < mGameOption.size(); n++) {
                    bool is_selected = (mGameSelected == n);
                    if (ImGui::Selectable(S(mGameOption[n].title), is_selected)) {
                        mGameSelected = n;
                        SetPlayerOpt();
                    }
                    if (is_selected) {
                        ImGui::SetItemDefaultFocus();
                    }
                }
                ImGui::EndCombo();
            }
            ImGui::NewLine();

            if (mPlayerOption.size()) {
                auto& selected = mGameOption[mGameSelected];
                ImGui::Columns(selected.playerColumns, 0, false);
                for (auto& player : mPlayerOption) {
                    changed |= ImGui::Checkbox(player.first.c_str(), &player.second);
                    ImGui::NextColumn();
                }
                ImGui::Columns(1);
            }
        }

        std::vector<std::string> candidate;
        for (auto& player : mPlayerOption) {
            if (player.second) {
                candidate.push_back(player.first);
            }
        }

        if (changed) {
            UpdateRoll();
        }

        float angle_cur;
        if (is_rolling) {
            angle_cur = mRoll.MInterpolation(time / (float)time_tot, angle_last, angle_fin);
            if (time < time_tot) {
                time++;
            } else {
                is_rolling = false;
            }
        } else {
            angle_cur = angle_fin;
        }
        int roll_result = mRoll.CalcIdx(angle_cur);

        auto wndSize = ImGui::GetWindowSize();
        mRoll.GuiDraw(angle_cur, roll_result, wndSize.y * 0.15f);

        if (!first_roll && !is_rolling) {
            auto result = roll_result;
            if (result != -1 && result < candidate.size()) {
                char outputStr[256];
                sprintf_s(outputStr, S(THPRAC_TOOLS_ROLL_RESULT), candidate[result].c_str());
                mRollText = outputStr;
                mRollGame = S(mGameOption[mGameSelected].title);
            }
        }

        if (GuiButtonRelCentered(mRollText.c_str(), 0.9f, ImVec2(1.0f, 0.08f))) {
            first_roll = false;
            is_rolling = true;
            time = 0;
            angle_last = angle_fin - floorf(angle_fin / (2.0f * std::numbers::pi)) * 2.0f * std::numbers::pi;
            angle_fin = (mRoll.GetRandomFloat() * 2.0f * std::numbers::pi) + 30.0f * std::numbers::pi;
        }

        if (mRollText != S(THPRAC_GAMEROLL_ROLL) && ImGui::BeginPopupContextItem("##roll_player_popup")) {
            if (ImGui::Selectable(S(THPRAC_TOOLS_RND_TURNTO_GAME))) {
                GuiLauncherMainSwitchTab(S(THPRAC_GAMES));
                LauncherGamesGuiSwitch(mRollGame.c_str());
            }
            ImGui::EndPopup();
        }

        if (!result) {
            if (mRndTextGen() == 1) {
                mRollText = S(THPRAC_GAMEROLL_EENY_MEENY);
            } else {
                mRollText = S(THPRAC_GAMEROLL_ROLL);
            }
        }
        return result;
    }

private:
    std::function<unsigned int(void)> mRndTextGen;
    std::vector<GameRoll> mGameOption;
    size_t mGameSelected = 0;
    std::vector<std::pair<std::string, bool>> mPlayerOption;
    std::string mRollText;
    std::string mRollGame;
};

class THGuiRollGame {
public:
    THRoll mRoll;

    bool first_roll;
    bool is_rolling;
    float angle_fin;
    float angle_last;
    float time;
    float time_tot;

    THGuiRollGame()
    {
        is_rolling = false;
        first_roll = true;
        angle_fin = -0.1f;
        angle_last = -0.1f;
        time_tot = 240.0f;
        time = 0.0f;

        mRndTextGen = GetRndGenerator(1u, 20u);
        for (auto& game : gGameRoll) {
            if (game.type == ROLL_MAIN) {
                game.selected = true;
            }
            mGameOption[game.type].push_back(game);
        }
        UpdateRoll();
        if (mRndTextGen() == 1) {
            mRollText = S(THPRAC_GAMEROLL_EENY_MEENY);
        } else {
            mRollText = S(THPRAC_GAMEROLL_ROLL);
        }
    }
    
    bool GuiGameTypeChkBox(const char* text, int idx)
    {
        if (ImGui::Checkbox(text, &(mGameTypeOpt[idx]))) {
            for (auto& game : mGameOption[idx]) {
                game.selected = mGameTypeOpt[idx];
            }
            return true;
        }
        return false;
    }
    void UpdateRoll()
    {
        std::vector<std::string> names;
        for (auto& gameType : mGameOption) {
            for (auto& game : gameType) {
                if (game.selected)
                    names.push_back(S(game.title));
            }
        }
        mRoll.InitRoll("rndgame", names, false);
    }
    bool GuiUpdate()
    {
        bool result = true;
        if (ImGui::Button(S(THPRAC_BACK))) {
            result = false;
        }
        ImGui::SameLine();
        GuiCenteredText(S(THPRAC_TOOLS_RND_GAME));
        ImGui::Separator();

        bool changed = false;
        if (ImGui::CollapsingHeader(S(THPRAC_TOOLS_RND_GAME)))
        {
            int i = 0;
            for (auto& gameType : mGameOption) {
                bool allSelected = true;
                ImGui::Columns(6, 0, false);
                for (auto& game : gameType) {
                    changed |= ImGui::Checkbox(S(game.title), &game.selected);
                    if (!game.selected) {
                        allSelected = false;
                    }
                    mGameTypeOpt[i] = allSelected;
                    ImGui::NextColumn();
                }
                ImGui::Columns(1);
                ImGui::NewLine();
                ++i;
            }
            ImGui::NewLine();
            changed |= GuiGameTypeChkBox(S(THPRAC_TOOLS_RND_GAME_PC98), 0);
            ImGui::SameLine();
            changed |= GuiGameTypeChkBox(S(THPRAC_GAMES_MAIN_SERIES), 1);
            ImGui::SameLine();
            changed |= GuiGameTypeChkBox(S(THPRAC_GAMES_SPINOFF_STG), 2);
            ImGui::SameLine();
            changed |= GuiGameTypeChkBox(S(THPRAC_GAMES_SPINOFF_OTHERS), 3);
        }

        std::vector<GameRoll> candidate;
        for (auto& gameType : mGameOption) {
            for (auto& game : gameType) {
                if (game.selected) {
                    candidate.push_back(game);
                }
            }
        }

        if (changed) {
            UpdateRoll();
        }

        float angle_cur;
        if (is_rolling) {
            angle_cur = mRoll.MInterpolation(time / (float)time_tot, angle_last, angle_fin);
            if (time < time_tot) {
                time++;
            } else {
                is_rolling = false;
            }
        } else {
            angle_cur = angle_fin;
        }
        int roll_result = mRoll.CalcIdx(angle_cur);

        auto wndSize = ImGui::GetWindowSize();
        mRoll.GuiDraw(angle_cur, roll_result, wndSize.y * 0.15f);

        if (!first_roll && !is_rolling) {
            auto result = roll_result;
            if (result != -1 && result < candidate.size()){
                char outputStr[256];
                sprintf_s(outputStr, S(THPRAC_TOOLS_ROLL_RESULT), S(candidate[result].title));
                mRollText = outputStr;
                mRollResult = candidate[result];
            }
        }

        if (GuiButtonRelCentered(mRollText.c_str(), 0.9f, ImVec2(1.0f, 0.08f))) {
            first_roll = false;
            is_rolling = true;
            time = 0;
            angle_last = angle_fin - floorf(angle_fin / (2.0f * std::numbers::pi)) * 2.0f * std::numbers::pi;
            angle_fin = (mRoll.GetRandomFloat() * 2.0f * std::numbers::pi) + 30.0f * std::numbers::pi;
        }
        if (mRollText != S(THPRAC_GAMEROLL_ROLL) && ImGui::BeginPopupContextItem("##roll_game_popup")) {
            if (mRollResult.playerSelect) {
                if (ImGui::Selectable(S(THPRAC_TOOLS_RND_TURNTO_PLAYER))) {
                    mRollText = S(THPRAC_GAMEROLL_ROLL);
                    LauncherToolsGuiSwitch(mRollResult.name);
                }
            }
            if (ImGui::Selectable(S(THPRAC_TOOLS_RND_TURNTO_GAME))) {
                GuiLauncherMainSwitchTab(S(THPRAC_GAMES));
                LauncherGamesGuiSwitch(mRollResult.name);
            }
            ImGui::EndPopup();
        }

        if (!result) {
            if (mRndTextGen() == 1) {
                mRollText = S(THPRAC_GAMEROLL_EENY_MEENY);
            } else {
                mRollText = S(THPRAC_GAMEROLL_ROLL);
            }
        }
        return result;
    }

private:
    std::function<unsigned int(void)> mRndTextGen;
    std::vector<GameRoll> mGameOption[4];
    std::string mRollText;
    GameRoll mRollResult;
    bool mGameTypeOpt[4];
};


class THToolsGui {
private:
    THToolsGui()
    {
        mGuiUpdFunc = [&]() { return GuiContent(); };
    }
    SINGLETON(THToolsGui);

public:
    void GuiUpdate()
    {
        GuiMain();
    }
    void Switch(const char* gameStr)
    {
        mGuiRollPlayer.SwitchGame(gameStr);
        mGuiUpdFunc = [&]() { return mGuiRollPlayer.GuiUpdate(); };
    }

private:
    float GetWidthRel(const char* text, float rsv = 0.0f)
    {
        auto offset = ImGui::GetFontSize() * rsv;
        return ImGui::GetStyle().FramePadding.x * 2 + ImGui::CalcTextSize(text).x + offset;
    }
    bool CenteredButton(const char* text, float posYRel, float width)
    {
        auto columnWidth = ImGui::GetColumnWidth();
        auto columnOffset = ImGui::GetColumnOffset();

        float cursorX = (columnWidth - width) / 2.0f + columnOffset;
        ImGui::SetCursorPosX(cursorX);
        GuiSetPosYRel(posYRel);
        return ImGui::Button(text, ImVec2(width, 0.0f));
    }
    bool GuiContent()
    {
        float y = 0.1f;
        float y_inc = 0.1f;
        auto width = GetWidthRel(S(THPRAC_TOOLS_APPLY_THPRAC), 2.0f);
        if (CenteredButton(S(THPRAC_TOOLS_APPLY_THPRAC), y, width)) {
            FindOngoingGame(true);
        }
        y += y_inc;
        if (CenteredButton(S(THPRAC_TOOLS_RND_GAME), y, width)) {
            mGuiUpdFunc = [&]() { return mGuiRollGame.GuiUpdate(); };
        }
        y += y_inc;
        if (CenteredButton(S(THPRAC_TOOLS_RND_PLAYER), y, width)) {
            mGuiUpdFunc = [&]() { return mGuiRollPlayer.GuiUpdate(); };
        }
        y += y_inc;
        if (CenteredButton(S(THPRAC_TOOLS_REACTION_TEST), y, width)) {
            mGuiUpdFunc = [&]() { return mGuiReactionTest.GuiUpdate(); };
        }
        y += y_inc;
        if (CenteredButton(S(THPRAC_TOOLS_ROLLF_FROM_FILE), y, width)) {
            mGuiUpdFunc = [&]() { return mGuiRollAll.GuiUpdate(); };
        }
        y += y_inc;
        if (CenteredButton(S(THPRAC_TOOLS_DICE), y, width)) {
            mGuiUpdFunc = [&]() { return mGuiDice.GuiUpdate(); };
        }
        y += y_inc;
        if (CenteredButton(S(THPRAC_KILL_ALL_GAME), y, width)) {
            auto game_killed = THClearGame();
            static char chs[256];
            sprintf_s(chs, S(THPRAC_KILL_ALL_GAME_DONE), game_killed.size());
            std::wstringstream ss;
            ss << utf8_to_utf16(chs) << L"\n";
            int n = 0;
            for (const auto& path : game_killed) {
                auto path_a = path;
                if (path_a.length() > 60) {
                    path_a = path_a.substr(0, 57) + L"...";
                }
                ss << L" - " << path_a << L"\n";
                n++;
                if (n > 32) {
                    //???
                    ss << "...";
                    break;
                }
            }
            MessageBoxW(NULL, ss.str().c_str(), L"done", MB_OK);
        }
        y += y_inc;
        ImGui::SameLine();
        HelpMarker(S(THPRAC_KILL_ALL_GAME_ALERT));
        return true;
    }
    void GuiMain()
    {
        if (!mGuiUpdFunc()) {
            mGuiUpdFunc = [&]() { return GuiContent(); };
        }
    }

    std::function<bool(void)> mGuiUpdFunc = []() { return true; };
    THGuiRollGame mGuiRollGame;
    THGuiRollPlayer mGuiRollPlayer;
    THGuiTestReactionTest mGuiReactionTest;
    THGuiRollAll mGuiRollAll;
    THGuiDice mGuiDice;
};

bool LauncherToolsGuiUpd()
{
    THToolsGui::singleton().GuiUpdate();
    return true;
}

void LauncherToolsGuiSwitch(const char* gameStr)
{
    THToolsGui::singleton().Switch(gameStr);
}
}
