#include "thprac_games.h"
#include "thprac_launcher_cfg.h"
#include "thprac_launcher_main.h"
#include "thprac_licence.h"
#include "thprac_gui_impl_dx8.h"
#include "thprac_gui_impl_dx9.h"
#include "thprac_utils.h"
#include "thprac_hook.h"
#include <dinput.h>
#include "../3rdParties/d3d8/include/d3d8.h"
#include <metrohash128.h>
#include <array>

#include <MinHook.h>
#include <format>
#include <vector>


#include <dwmapi.h>
#pragma comment(lib, "dwmapi.lib")

namespace THPrac {
#pragma region Gui Wrapper

int g_gameGuiImpl = -1;
DWORD* g_gameGuiDevice = nullptr;
DWORD* g_gameGuiHwnd = nullptr;
HIMC g_gameIMCCtx = 0;
bool g_disable_xkey = false;
bool g_disable_shiftkey = false;
bool g_disable_zkey = false;

bool g_disable_locale_change_hotkey = true;

enum SOCD_Setting {SOCD_Default,SOCD_2,SOCD_N};
SOCD_Setting g_socd_setting = SOCD_Default;
bool g_disable_f10_11_13 = false;
bool g_pauseBGM_06 = false;
std::string g_name_06;
bool g_forceRenderCursor=false;
bool g_disable_max_btn = true;
bool g_disable_joy = false;
bool g_record_key_aps = false;
AdvancedIGI_Options g_adv_igi_options;

bool g_useCustomFont = false;
std::string g_customFont = "MS Gothic";

BOOL(WINAPI* g_realGetKeyboardState)(PBYTE lpKeyboardState);
HRESULT(STDMETHODCALLTYPE* g_realGetDeviceState)(LPDIRECTINPUTDEVICE8 thiz, DWORD, LPVOID);
HFONT(WINAPI* g_realCreateFontA)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline,DWORD bStrikeOut,DWORD iCharSet,DWORD iOutPrecision,DWORD iClipPrecision,DWORD iQuality,DWORD iPitchAndFamily,LPCSTR pszFaceName);
MMRESULT (WINAPI *g_realJoyGetDevCapsA)(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
MMRESULT (WINAPI *g_realJoyGetPosEx)(UINT uJoyID, LPJOYINFOEX pji);
DWORD (WINAPI *g_realXInputGetState)(DWORD dwUserIndex, void* pState);
HRESULT (WINAPI* g_realEnumDevices)(LPDIRECTINPUT8 thiz, DWORD dwDevType, LPDIENUMDEVICESCALLBACKW lpCallback, LPVOID pvRef,DWORD dwFlags);


// HRESULT (STDMETHODCALLTYPE *g_realPresent)(DWORD* thiz, const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion);
// HRESULT STDMETHODCALLTYPE Present_Changed(DWORD* thiz, const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion)
// {
//     auto res = g_realPresent(thiz, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion);
//     return res;
// }

HRESULT WINAPI EnumDevices_Changed(LPDIRECTINPUT8 thiz, DWORD dwDevType, LPDIENUMDEVICESCALLBACKW lpCallback, LPVOID pvRef, DWORD dwFlags)
{
    if (g_disable_joy && dwDevType == DI8DEVCLASS_GAMECTRL)
        return DI_OK;
    return g_realEnumDevices(thiz, dwDevType, lpCallback, pvRef, dwFlags);
}

MMRESULT WINAPI joyGetDevCapsA_Changed(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc) {
    if (g_disable_joy)
        return MMSYSERR_NODRIVER;
    return g_realJoyGetDevCapsA(uJoyID, pjc, cbjc);
}

MMRESULT WINAPI joyGetPosEx_Changed(UINT uJoyID, LPJOYINFOEX pji) { 
    if (g_disable_joy)
        return MMSYSERR_NODRIVER;
    return g_realJoyGetPosEx(uJoyID, pji);
}

DWORD WINAPI XInputGetState_Changed(DWORD dwUserIndex, void* pState)
{
    if (g_disable_joy)
        return ERROR_DEVICE_NOT_CONNECTED;
    return g_realXInputGetState(dwUserIndex, pState);
}

HFONT WINAPI CreateFontA_Changed
(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline,
    DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
{
    static std::vector<std::string> fonts = EnumAllFonts();
    char font_Gothic[] = { 0x82, 0x6C, 0x82, 0x72, 0x20, 0x83, 0x53, 0x83, 0x56, 0x83, 0x62, 0x83, 0x4E, 0x00 }; // ‚l‚r ƒSƒVƒbƒN, MS Gothic
    char font_Mincho[] = { 0x82, 0x6C, 0x82, 0x72, 0x20, 0x96, 0xBE, 0x92, 0xA9, 0x00 }; // ‚l‚r –¾’©, MS Mincho
    if (g_useCustomFont)
        return g_realCreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, g_customFont.c_str());
    if (strcmp(font_Gothic, pszFaceName) == 0) {
        return g_realCreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, "MS Gothic");
    }else if (strcmp(font_Mincho, pszFaceName) == 0) {
        // some computer might not have mincho font
        if (std::find(fonts.begin(), fonts.end(), "MS Mincho") == fonts.end())
            return g_realCreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, "MS Gothic");
        return g_realCreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, "MS Mincho");
    }
    return g_realCreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
}


#define IS_KEY_DOWN(x) (((x)&0x80)==0x80)

enum Key {
    K_LEFT,
    K_RIGHT,
    K_UP,
    K_DOWN
};

extern std::unordered_map<KeyDefine, KeyDefine, KeyDefineHashFunction> g_keybind;

BOOL WINAPI GetKeyboardState_Changed(PBYTE keyBoardState)
{
    bool res = g_realGetKeyboardState(keyBoardState);
    if (g_keybind.size() != 0)
    {
        static BYTE new_keyBoardState[256] = { 0 };
        bool new_keyBoardState_changed[256] = { 0 };
        memcpy_s(new_keyBoardState,256, keyBoardState, 256);
        for (auto& bind : g_keybind) {
            if (IS_KEY_DOWN(keyBoardState[bind.second.vk])) {
                new_keyBoardState[bind.first.vk] |= 0x80;
                if (!new_keyBoardState_changed[bind.first.vk])
                    new_keyBoardState[bind.second.vk] &= (~0x80);
                new_keyBoardState_changed[bind.first.vk] = true;
            }
        }
        if (IS_KEY_DOWN(new_keyBoardState[VK_LSHIFT]) || IS_KEY_DOWN(new_keyBoardState[VK_RSHIFT]))
        {
            new_keyBoardState[VK_SHIFT] |= 0x80;
        }
        if (IS_KEY_DOWN(new_keyBoardState[VK_LCONTROL]) || IS_KEY_DOWN(new_keyBoardState[VK_RCONTROL])) {
            new_keyBoardState[VK_CONTROL] |= 0x80;
        }
        if (IS_KEY_DOWN(new_keyBoardState[VK_LMENU]) || IS_KEY_DOWN(new_keyBoardState[VK_RMENU])) {
            new_keyBoardState[VK_MENU] |= 0x80;
        }
        memcpy_s(keyBoardState, 256, new_keyBoardState, 256);
    }
    if (g_disable_xkey) {
        keyBoardState['X'] = 0x0;
    }
    if (g_disable_shiftkey) {
        keyBoardState[VK_LSHIFT] = keyBoardState[VK_LSHIFT] = keyBoardState[VK_SHIFT] = 0x0;
    }
    if (g_disable_zkey) {
        keyBoardState['Z']= 0x0;
    }
    if (g_disable_f10_11_13){
        keyBoardState[VK_F10] = 0x0;
    }
    if (g_socd_setting == SOCD_Default) {
        return res;
    }
    static BYTE last_keyBoardState[256] = { 0 };
    static uint32_t cur_time = 0;
    static uint32_t keyBoard_press_time[4] = { 0 };

    cur_time++;
    
    if (IS_KEY_DOWN(keyBoardState[VK_LEFT]) && !IS_KEY_DOWN(last_keyBoardState[VK_LEFT]))
        keyBoard_press_time[K_LEFT] = cur_time;
    if (IS_KEY_DOWN(keyBoardState[VK_RIGHT]) && !IS_KEY_DOWN(last_keyBoardState[VK_RIGHT]))
        keyBoard_press_time[K_RIGHT] = cur_time;
    if (IS_KEY_DOWN(keyBoardState[VK_UP]) && !IS_KEY_DOWN(last_keyBoardState[VK_UP]))
        keyBoard_press_time[K_UP] = cur_time;
    if (IS_KEY_DOWN(keyBoardState[VK_DOWN]) && !IS_KEY_DOWN(last_keyBoardState[VK_DOWN]))
        keyBoard_press_time[K_DOWN] = cur_time;

    memcpy_s(last_keyBoardState, 256, keyBoardState, 256);
    
    
    if (IS_KEY_DOWN(keyBoardState[VK_LEFT]) && IS_KEY_DOWN(keyBoardState[VK_RIGHT])){
        if (g_socd_setting == SOCD_2)
        {
            if (keyBoard_press_time[K_LEFT] > keyBoard_press_time[K_RIGHT]) {
                keyBoardState[VK_RIGHT] = 0;
            } else {
                keyBoardState[VK_LEFT] = 0;
            }
        } else if (g_socd_setting == SOCD_N) {
            keyBoardState[VK_RIGHT] = 0;
            keyBoardState[VK_LEFT] = 0;
        }
       
    }
    if (IS_KEY_DOWN(keyBoardState[VK_DOWN]) && IS_KEY_DOWN(keyBoardState[VK_UP])) {
        if (g_socd_setting == SOCD_2) {
            if (keyBoard_press_time[K_UP] > keyBoard_press_time[K_DOWN]) {
                keyBoardState[VK_DOWN] = 0;
            } else {
                keyBoardState[VK_UP] = 0;
            }
        } else if (g_socd_setting == SOCD_N) {
            keyBoardState[VK_DOWN] = 0;
            keyBoardState[VK_UP] = 0;
        }
    }
    return res;
}

HookCtx g_dinput8Hook;


HRESULT STDMETHODCALLTYPE GetDeviceState_Changed(LPDIRECTINPUTDEVICE8 thiz, DWORD num, LPVOID state)
{
    if (num != 256) {//no keyboard
        if (g_disable_joy)
            return DIERR_INPUTLOST;//8007001E   
        return g_realGetDeviceState(thiz, num, state);
    }
    
    HRESULT res = g_realGetDeviceState(thiz, num, state);
    if (g_keybind.size() != 0) {
        static BYTE new_keyBoardState[256] = { 0 };
        bool new_keyBoardState_changed[256] = { 0 };
        memcpy_s(new_keyBoardState, num, ((BYTE*)state), num);
        for (auto& bind : g_keybind) {
            if (IS_KEY_DOWN(((BYTE*)state)[bind.second.dik])) {
                new_keyBoardState[bind.first.dik] |= 0x80;
                if (!new_keyBoardState_changed[bind.first.dik])
                    new_keyBoardState[bind.second.dik] &= (~0x80);
                new_keyBoardState_changed[bind.first.dik] = true;
            }
        }
        memcpy_s(((BYTE*)state), num, new_keyBoardState, num);
    }
    if (g_disable_xkey) {
        ((BYTE*)state)[DIK_X] = 0x0;
    }
    if (g_disable_shiftkey) {
        ((BYTE*)state)[DIK_LSHIFT] = 0x0;
        ((BYTE*)state)[DIK_RSHIFT] = 0x0;
    }
    if (g_disable_zkey) {
        ((BYTE*)state)[DIK_Z] = 0x0;
    }
    if (g_disable_f10_11_13) {
        ((BYTE*)state)[DIK_F10] = 0x0;
    }
    if (g_socd_setting == SOCD_Default) {
        return res;
    }
    static BYTE last_keyBoardState[256] = { 0 };
    static uint32_t cur_time = 0;
    static uint32_t keyBoard_press_time[4] = { 0 };

    BYTE* keyBoardState = (BYTE*)state;
    cur_time++;

    if (IS_KEY_DOWN(keyBoardState[DIK_LEFTARROW]) && !IS_KEY_DOWN(last_keyBoardState[DIK_LEFTARROW]))
        keyBoard_press_time[K_LEFT] = cur_time;
    if (IS_KEY_DOWN(keyBoardState[DIK_RIGHTARROW]) && !IS_KEY_DOWN(last_keyBoardState[DIK_RIGHTARROW]))
        keyBoard_press_time[K_RIGHT] = cur_time;
    if (IS_KEY_DOWN(keyBoardState[DIK_UPARROW]) && !IS_KEY_DOWN(last_keyBoardState[DIK_UPARROW]))
        keyBoard_press_time[K_UP] = cur_time;
    if (IS_KEY_DOWN(keyBoardState[DIK_DOWNARROW]) && !IS_KEY_DOWN(last_keyBoardState[DIK_DOWNARROW]))
        keyBoard_press_time[K_DOWN] = cur_time;

    memcpy_s(last_keyBoardState, num, keyBoardState, num);

    if (IS_KEY_DOWN(keyBoardState[DIK_LEFTARROW]) && IS_KEY_DOWN(keyBoardState[DIK_RIGHTARROW])) {
        if (g_socd_setting == SOCD_2)
        {
            if (keyBoard_press_time[K_LEFT] > keyBoard_press_time[K_RIGHT]) {
                keyBoardState[DIK_RIGHTARROW] = 0;
            } else {
                keyBoardState[DIK_LEFTARROW] = 0;
            }
        }else if (g_socd_setting == SOCD_N){
            keyBoardState[DIK_RIGHTARROW] = 0;
            keyBoardState[DIK_LEFTARROW] = 0;
        }
        
    }
    if (IS_KEY_DOWN(keyBoardState[DIK_DOWNARROW]) && IS_KEY_DOWN(keyBoardState[DIK_UPARROW])) {
        if (g_socd_setting == SOCD_2) {
            if (keyBoard_press_time[K_UP] > keyBoard_press_time[K_DOWN]) {
                keyBoardState[DIK_DOWNARROW] = 0;
            } else {
                keyBoardState[DIK_UPARROW] = 0;
            }
        } else if (g_socd_setting == SOCD_N) {
            keyBoardState[DIK_DOWNARROW] = 0;
            keyBoardState[DIK_UPARROW] = 0;
        }
    }
    return res;
}



void GameGuiInit(game_gui_impl impl, int device, int hwnd_addr,
    Gui::ingame_input_gen_t input_gen, int reg1, int reg2, int reg3,
    int wnd_size_flag, float x, float y)
{
    ingame_mb_init();
    ::ImGui::CreateContext();
    g_gameGuiImpl = impl;
    g_gameGuiDevice = (DWORD*)device;
    g_gameGuiHwnd = (DWORD*)hwnd_addr;
    g_gameIMCCtx = ImmAssociateContext(*(HWND*)hwnd_addr, 0);

    // Set Locale
    GuiLauncherLocaleInit();

    switch (impl) {
    case THPrac::IMPL_WIN32_DX8:
        // Impl
        Gui::ImplDX8Init((IDirect3DDevice8*)*g_gameGuiDevice);
        Gui::ImplWin32Init((HWND)*g_gameGuiHwnd);

        // Hooks
        Gui::ImplDX8HookReset();
        Gui::ImplWin32HookWndProc();
        break;
    case THPrac::IMPL_WIN32_DX9:
        // Impl
        Gui::ImplDX9Init((IDirect3DDevice9*)*g_gameGuiDevice);
        Gui::ImplWin32Init((HWND)*g_gameGuiHwnd);

        // Hooks
        Gui::ImplDX9HookReset();
        Gui::ImplWin32HookWndProc();
        break;
    default:
        break;
    }

    // Inputs
    Gui::InGameInputInit(input_gen, reg1, reg2, reg3);

    // Display size setup
    auto& io = ::ImGui::GetIO();
    if (wnd_size_flag == -1) {
        io.DisplaySize = { x, y };
        Gui::LocaleCreateFont(io.DisplaySize.x * 0.025f);
    } else if (wnd_size_flag == -2) {
        float dispX, dispY;
        if (x > 1.6) {
            dispX = 1280.0f;
            dispY = 960.0f;
        } else if (x > 1.1) {
            dispX = 960.0f;
            dispY = 720.0f;
        } else {
            dispX = 640.0f;
            dispY = 480.0f;
        }
        Gui::ImplDX9AdjustDispSize();
        Gui::LocaleCreateFont(dispX * 0.025f);
    } else {
        switch (wnd_size_flag) {
        case 2:
        case 5:
            io.DisplaySize = { 1280.0f, 960.0f };
            break;
        case 1:
        case 4:
            io.DisplaySize = { 960.0f, 720.0f };
            break;
        default:
            io.DisplaySize = { 640.0f, 480.0f };
            break;
        }
        Gui::LocaleCreateFont(io.DisplaySize.x * 0.025f);
    }
    
    if (LauncherCfgInit(true)) {
        if (!Gui::ImplWin32CheckFullScreen())
        {
            bool resizable_window = false, change_window_when_open = false,init_window_pos=true;
            LauncherSettingGet("disableMax_btn", g_disable_max_btn);
            LauncherSettingGet("resizable_window", resizable_window);
            LauncherSettingGet("change_window_size_when_open", change_window_when_open);
            LauncherSettingGet("init_window_pos", init_window_pos);

            if (g_disable_max_btn || resizable_window)
            {
                auto longPtr = GetWindowLongW(*(HWND*)hwnd_addr, GWL_STYLE);
                if (resizable_window)
                    longPtr |= WS_SIZEBOX;
                if (g_disable_max_btn)
                    longPtr = longPtr & (~WS_MAXIMIZEBOX);
                SetWindowLongW(*(HWND*)hwnd_addr, GWL_STYLE, longPtr);
                if (resizable_window)
                {
                    RECT wndRect;
                    GetClientRect(*(HWND*)hwnd_addr, &wndRect);
                    auto frameSize = GetSystemMetrics(SM_CXSIZEFRAME) * 2;
                    auto captionSize = GetSystemMetrics(SM_CYCAPTION);
                    SetWindowPos(*(HWND*)hwnd_addr, HWND_NOTOPMOST,
                        0, 0, wndRect.right + frameSize, wndRect.bottom + frameSize + captionSize,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
                }
            }
            if (init_window_pos) {
                RECT wndRect;
                GetWindowRect(*(HWND*)hwnd_addr, &wndRect);
                if (wndRect.left < 0 || wndRect.top < 0 || (wndRect.bottom + wndRect.top) / 2 >= GetSystemMetrics(SM_CYSCREEN) || (wndRect.right + wndRect.left) / 2 >= GetSystemMetrics(SM_CXSCREEN))
                    SetWindowPos(*(HWND*)hwnd_addr, HWND_NOTOPMOST, 0, 0, wndRect.right - wndRect.left, wndRect.bottom - wndRect.top, SWP_NOZORDER | SWP_FRAMECHANGED);
            }
            if (change_window_when_open) {
                std::array<int, 2> windowsz = { 0, 0 };
                if (LauncherSettingGet("changed_window_size", windowsz) && windowsz[0] > 0 && windowsz[1] > 0) {
                        RECT wndRect;
                        RECT clientRect;
                        GetClientRect(*(HWND*)hwnd_addr, &clientRect);
                        GetWindowRect(*(HWND*)hwnd_addr, &wndRect);
                        int szx = (wndRect.right - wndRect.left)-(clientRect.right-clientRect.left);
                        int szy = (wndRect.bottom - wndRect.top) - (clientRect.bottom - clientRect.top);
                        auto frameSize = GetSystemMetrics(SM_CXSIZEFRAME) * 2;
                        auto captionSize = GetSystemMetrics(SM_CYCAPTION);
                        SetWindowPos(*(HWND*)hwnd_addr, HWND_NOTOPMOST,
                            0, 0, windowsz[0] + szx, windowsz[1] + szy,
                            SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
                }
            }
           
        }
        LauncherSettingGet("disable_locale_change_hotkey", g_disable_locale_change_hotkey);
        LauncherSettingGet("keyboard_SOCDv2", (int &)g_socd_setting);
        LauncherSettingGet("force_render_cursor", g_forceRenderCursor);
        LauncherSettingGet("pauseBGM_06", g_pauseBGM_06);
        
        memset(&g_adv_igi_options, 0, sizeof(g_adv_igi_options));

        LauncherSettingGet("autoInputName_06", g_adv_igi_options.th06_autoname);
        std::string name06 = "";
        LauncherSettingGet("autoName_06", name06);
        if (name06.size() >= 1 && name06.size() <= 9) {
            strcpy_s(g_adv_igi_options.th06_autoname_name, name06.c_str());
        }

        LauncherSettingGet("th10_ud_Replay", g_adv_igi_options.th10_ud_Replay);

        LauncherSettingGet("th18_force_card", g_adv_igi_options.th18_force_card);
        LauncherSettingGet("th18_card_st1", g_adv_igi_options.th18_cards[0]);
        LauncherSettingGet("th18_card_st2", g_adv_igi_options.th18_cards[1]);
        LauncherSettingGet("th18_card_st3", g_adv_igi_options.th18_cards[2]);
        LauncherSettingGet("th18_card_st4", g_adv_igi_options.th18_cards[3]);
        LauncherSettingGet("th18_card_st5", g_adv_igi_options.th18_cards[4]);
        LauncherSettingGet("th18_card_st7", g_adv_igi_options.th18_cards[5]);

        LauncherSettingGet("auto_disable_master", g_adv_igi_options.disable_master_autoly);
        LauncherSettingGet("auto_map_inf_life_to_no_continue", g_adv_igi_options.map_inf_life_to_no_continue);
        LauncherSettingGet("auto_th06_bg_fix", g_adv_igi_options.th06_bg_fix);
        LauncherSettingGet("auto_th06_fix_seed", g_adv_igi_options.th06_fix_seed);
        LauncherSettingGet("th06_seed", g_adv_igi_options.th06_seed);
        g_adv_igi_options.th06_seed = std::clamp(g_adv_igi_options.th06_seed, 0, 65535);

        LauncherSettingGet("auto_th06_rep_marker", g_adv_igi_options.th06_showRepMarker);
        LauncherSettingGet("auto_th06_show_rank", g_adv_igi_options.th06_showRank);
        LauncherSettingGet("auto_th06_disable_rank_drop", g_adv_igi_options.th06_disable_drop_rank);
        LauncherSettingGet("auto_th06_show_hitbox", g_adv_igi_options.th06_show_hitbox);
        LauncherSettingGet("auto_th11_show_hint", g_adv_igi_options.th11_showHint);
        LauncherSettingGet("auto_th13_show_hits", g_adv_igi_options.th13_showHits);
        LauncherSettingGet("auto_th13_show_hitbar", g_adv_igi_options.th13_showHitBar);
        LauncherSettingGet("auto_th14_show_bonus", g_adv_igi_options.th14_showBonus);
        LauncherSettingGet("auto_th14_show_item_cnt", g_adv_igi_options.th14_showItemsCount);
        LauncherSettingGet("auto_th14_show_drop_bar", g_adv_igi_options.th14_showDropBar);
        LauncherSettingGet("auto_th15_show_rate", g_adv_igi_options.th15_showShootingDownRate);

        LauncherSettingGet("auto_keyboard_monitor", g_adv_igi_options.show_keyboard_monitor);
        if (!LauncherSettingGet("kb_separated",             g_adv_igi_options.keyboard_style.separated))                g_adv_igi_options.keyboard_style.separated = true;
        if (!LauncherSettingGet("kb_aps",                   g_adv_igi_options.keyboard_style.show_aps))                 g_adv_igi_options.keyboard_style.show_aps = true;
        if (!LauncherSettingGet("kb_border_color_press",    g_adv_igi_options.keyboard_style.border_color_press))       g_adv_igi_options.keyboard_style.border_color_press = 0xFFFFFFFF;
        if (!LauncherSettingGet("kb_border_color_release",  g_adv_igi_options.keyboard_style.border_color_release))     g_adv_igi_options.keyboard_style.border_color_release = 0xFFFFFFFF;
        if (!LauncherSettingGet("kb_fill_color_press",      g_adv_igi_options.keyboard_style.fill_color_press))         g_adv_igi_options.keyboard_style.fill_color_press = 0xFFFF4444;
        if (!LauncherSettingGet("kb_fill_color_release",    g_adv_igi_options.keyboard_style.fill_color_release))       g_adv_igi_options.keyboard_style.fill_color_release = 0xFFFFCCCC;
        if (!LauncherSettingGet("kb_text_color_press",      g_adv_igi_options.keyboard_style.text_color_press))         g_adv_igi_options.keyboard_style.text_color_press = 0xFFFFFFFF;
        if (!LauncherSettingGet("kb_text_color_release",    g_adv_igi_options.keyboard_style.text_color_release))       g_adv_igi_options.keyboard_style.text_color_release = 0xFFFFFFFF;
        if (!LauncherSettingGet("kb_text_color_style",      g_adv_igi_options.keyboard_style.type))                     g_adv_igi_options.keyboard_style.type = 2;
        float kb_padding = 0.05f;
        LauncherSettingGet("kb_padding", kb_padding);
        g_adv_igi_options.keyboard_style.padding = { kb_padding, kb_padding };
        g_adv_igi_options.keyboard_style.size = { 34.0f, 34.0f };
        LauncherSettingGet("kb_type", g_adv_igi_options.keyboard_style.type);

        bool useCorrectJaFonts=false;
        LauncherSettingGet("use_custom_fonts", g_useCustomFont);
        LauncherSettingGet("use_correct_ja_fonts", useCorrectJaFonts);
        if (g_useCustomFont || useCorrectJaFonts)
        {
            LPVOID pTarget;
            MH_CreateHookApiEx(L"GDI32.dll", "CreateFontA", CreateFontA_Changed, (void**)&g_realCreateFontA, &pTarget);
            MH_EnableHook(pTarget);
        }
        if (g_useCustomFont)
        {
            int font = 0;
            LauncherSettingGet("custom_font", font);
            auto &all_fonts = EnumAllFonts();
            if (font >= 0 && font < all_fonts.size())
                g_customFont = all_fonts[font];
        }
        

        bool disable_f10 = false;
        if (LauncherSettingGet("disable_F10_11_13", disable_f10) && disable_f10) {
            if (device == 0x4c3288 // 11
                || device == 0x4ce8f0 // 12 
                || device == 0x4d0cd8 // 125 
                || device == 0x4d2e70 // 128
                || device == 0x4dc6a8 // 13
                )
            {
                g_disable_f10_11_13 = true;
            }else{
                g_disable_f10_11_13 = false;
            }
            
        } else {
            g_disable_f10_11_13 = false;
        }

        LauncherSettingGet_KeyBind();

        if (LauncherSettingGet("disableJoy", g_disable_joy) && g_disable_joy)
        {
            LPVOID pTarget;
            if (MH_OK == MH_CreateHookApiEx(L"winmm.dll", "joyGetPosEx", joyGetPosEx_Changed, (void**)&g_realJoyGetPosEx, &pTarget))
                MH_EnableHook(pTarget);
            if(MH_OK == MH_CreateHookApiEx(L"winmm.dll", "joyGetDevCapsA", joyGetDevCapsA_Changed, (void**)&g_realJoyGetDevCapsA, &pTarget))
                MH_EnableHook(pTarget);
            if (MH_OK == MH_CreateHookApiEx(L"xinput1_3.dll", "XInputGetState", XInputGetState_Changed, (void**)&g_realXInputGetState, &pTarget))
                MH_EnableHook(pTarget);
        }
        int theme;
        if (LauncherSettingGet("theme", theme)) {
            const char* userThemeName;
            if (LauncherSettingGet("theme_user", userThemeName))
                SetTheme(theme, utf8_to_utf16(userThemeName).c_str());
            else
                SetTheme(theme);
        } else
            ImGui::StyleColorsDark();
    }else{
        ::ImGui::StyleColorsDark();
        g_adv_igi_options.keyboard_style.separated = true;
        g_adv_igi_options.keyboard_style.border_color_press = 0xFFFFFFFF;
        g_adv_igi_options.keyboard_style.border_color_release = 0xFFFFFFFF;
        g_adv_igi_options.keyboard_style.fill_color_press = 0xFFFF4444;
        g_adv_igi_options.keyboard_style.fill_color_release = 0xFFFFCCCC;
        g_adv_igi_options.keyboard_style.text_color_press = 0xFFFFFFFF;
        g_adv_igi_options.keyboard_style.text_color_release = 0xFFFFFFFF;
        g_adv_igi_options.keyboard_style.type = 2;
        g_adv_igi_options.keyboard_style.padding = { 0.0, 0.0 };

    }

     { // hook keyboard to enable SOCD and X-disable
        LPVOID pTarget;
        if(MH_OK==MH_CreateHookApiEx(L"user32.dll", "GetKeyboardState", GetKeyboardState_Changed, (void**)&g_realGetKeyboardState, &pTarget))
            MH_EnableHook(pTarget);

        LPDIRECTINPUT8 pdinput;
        DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8A, (void**)&pdinput, NULL);
        if (FAILED(pdinput)) {
        }
        void* EnumDeviceAddr = (*(void***)pdinput)[4];
        if (g_disable_joy){
            MH_CreateHook(EnumDeviceAddr, EnumDevices_Changed, (LPVOID*)&g_realEnumDevices);
            MH_EnableHook(EnumDeviceAddr);
        }
        LPDIRECTINPUTDEVICE8 ddevice;
        pdinput->CreateDevice(GUID_SysKeyboard, &ddevice, NULL);
        void* GetDeviceStateAddr = (*(void***)ddevice)[9];
        MH_CreateHook(GetDeviceStateAddr, GetDeviceState_Changed, (LPVOID*)&g_realGetDeviceState);
        MH_EnableHook(GetDeviceStateAddr);
        pdinput->Release();
        ddevice->Release();
        // dinput8 is inited before GameGuiInit(), so create a new device for hook
    }

     // if(device){
     //    void* pInterface = (void*)(*(int*)device);
     //    void* PresentAddr;
     //    switch (impl) {
     //    case THPrac::IMPL_WIN32_DX8:
     //        PresentAddr = (*(void***)pInterface)[15];
     //        break;
     //    default:
     //    case THPrac::IMPL_WIN32_DX9:
     //        PresentAddr = (*(void***)pInterface)[17];
     //        break;
     //    }
     //    MH_CreateHook(PresentAddr, Present_Changed, (LPVOID*)&g_realPresent);
     //    MH_EnableHook(PresentAddr);
     // }
    // Imgui settings
    io.IniFilename = nullptr;
}

int GameGuiProgress = 0;
void GameGuiBegin(game_gui_impl impl, bool game_nav)
{
    // Acquire game input
    ImGuiIO& io = ImGui::GetIO();
    if (game_nav) {
        Gui::GuiNavFocus::GlobalDisable(false);
        io.NavInputs[ImGuiNavInput_DpadUp] = Gui::InGameInputGet(VK_UP);
        io.NavInputs[ImGuiNavInput_DpadDown] = Gui::InGameInputGet(VK_DOWN);
        io.NavInputs[ImGuiNavInput_DpadLeft] = Gui::InGameInputGet(VK_LEFT);
        io.NavInputs[ImGuiNavInput_DpadRight] = Gui::InGameInputGet(VK_RIGHT);
    } else {
        Gui::GuiNavFocus::GlobalDisable(true);
    }
    switch (impl) {
    case THPrac::IMPL_WIN32_DX8:
        // New frame
        Gui::ImplDX8NewFrame();
        Gui::ImplWin32NewFrame();
        ::ImGui::NewFrame();
        break;
    case THPrac::IMPL_WIN32_DX9:
        // New frame
        Gui::ImplDX9NewFrame();
        Gui::ImplWin32NewFrame();
        ::ImGui::NewFrame();
        break;
    }
    GameGuiProgress = 1;
}

void GameGuiEnd(bool draw_cursor)
{
    if (GameGuiProgress != 1)
        return;
    // try to re-hook wnd proc
    // now it's no need since win32 hook method is changed
    
    // Draw cursor if needed
    if (draw_cursor && (g_forceRenderCursor || Gui::ImplWin32CheckFullScreen())) {
        auto& io = ::ImGui::GetIO();
        io.MouseDrawCursor = true;
    }

    // Locale Change
    if (!ImGui::IsAnyItemActive()) {
        if (!g_disable_locale_change_hotkey)
        {
            if (Gui::ImplWin32CheckHotkey(0x00010031)) {
                Gui::LocaleSet(Gui::LOCALE_JA_JP);
            } else if (Gui::ImplWin32CheckHotkey(0x00010032)) {
                Gui::LocaleSet(Gui::LOCALE_ZH_CN);
            } else if (Gui::ImplWin32CheckHotkey(0x00010033)) {
                Gui::LocaleSet(Gui::LOCALE_EN_US);
            }
        }
    }
    ::ImGui::EndFrame();
    GameGuiProgress = 2;
}

void GameGuiRender(game_gui_impl impl)
{
    if (GameGuiProgress != 2)
        return;
    Gui::ImplWin32Check((void*)*g_gameGuiHwnd);
    switch (impl) {
    case THPrac::IMPL_WIN32_DX8:
        // End frame and render
        Gui::ImplDX8Check((IDirect3DDevice8*)*g_gameGuiDevice);
        ::ImGui::Render();
        Gui::ImplDX8RenderDrawData(::ImGui::GetDrawData());
        break;
    case THPrac::IMPL_WIN32_DX9:
        // End frame and render
        Gui::ImplDX9Check((IDirect3DDevice9*)*g_gameGuiDevice);
        ::ImGui::Render();
        Gui::ImplDX9RenderDrawData(::ImGui::GetDrawData());
        break;
    default:
        break;
    }
    GameGuiProgress = 0;
}

void TryKeepUpRefreshRate(void* address, void* address2)
{
    if (LauncherCfgInit(true)) {
        bool tryRefreshRateChange = false;
        if (LauncherSettingGet("unlock_refresh_rate", tryRefreshRateChange) && tryRefreshRateChange) {
            DWORD oldProtect;

            VirtualProtect(address, 1, PAGE_EXECUTE_READWRITE, &oldProtect);
            *(uint8_t*)address = 0;
            VirtualProtect(address, 1, oldProtect, &oldProtect);

            VirtualProtect(address2, 1, PAGE_EXECUTE_READWRITE, &oldProtect);
            *(uint8_t*)address2 = (uint8_t)0xeb;
            VirtualProtect(address2, 1, oldProtect, &oldProtect);
        }
    }
}

void TryKeepUpRefreshRate(void* address)
{
    if (LauncherCfgInit(true)) {
        bool tryRefreshRateChange = false;
        if (LauncherSettingGet("unlock_refresh_rate", tryRefreshRateChange) && tryRefreshRateChange) {
            DWORD oldProtect;

            VirtualProtect(address, 1, PAGE_EXECUTE_READWRITE, &oldProtect);
            *(uint8_t*)address = 0;
            VirtualProtect(address, 1, oldProtect, &oldProtect);
        }
    }
}
#pragma endregion

#pragma region Advanced Options Menu

void MsgBox(UINT type, const char* title, const char* msg, const char* msg2 = nullptr)
{
    static wchar_t _title[256];
    static wchar_t _msg[256];
    static wchar_t _msg2[256];
    MultiByteToWideChar(CP_UTF8, 0, title, -1, _title, 256);
    MultiByteToWideChar(CP_UTF8, 0, msg, -1, _msg, 256);
    if (msg2) {
        MultiByteToWideChar(CP_UTF8, 0, msg2, -1, _msg2, 256);
        wcscat_s(_msg, _msg2);
    }
    MessageBoxW(nullptr, _msg, _title, type);
}

void CenteredText(const char* text, float wndX)
{
    ImGui::SetCursorPosX((wndX - ImGui::CalcTextSize(text).x) / 2.0f);
    ImGui::TextUnformatted(text);
}

float GetRelWidth(float rel)
{
    return ImGui::GetIO().DisplaySize.x * rel;
}

float GetRelHeight(float rel)
{
    return ImGui::GetIO().DisplaySize.y * rel;
}

void CalcFileHash(const wchar_t* file_name, uint64_t hash[2])
{
    hash[0] = 0ll;
    hash[1] = 0ll;

    MappedFile file(file_name);
    if (file.fileMapView)
        MetroHash128::Hash((uint8_t*)file.fileMapView, file.fileSize, (uint8_t*)hash);
}

void HelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

int FPSHelper(adv_opt_ctx& ctx, bool repStatus, bool vpFast, bool vpSlow, FPSHelperCallback* callback)
{
    static bool isDebugAccActive = false;
    int res = 0;
    if (ctx.fps_status <= 0) {
        return 0;
    }
    if (ctx.fps_debug_acc && Gui::ImplWin32GetKeyFrame(VK_SPACE)) {
        if (!isDebugAccActive) {
            isDebugAccActive = true;
            res = 1;
        }
        if (ctx.fps_status == 2) {
            callback(repStatus ? 9999 : (ctx.fps_replay_fast > 1200 ? 9999 : ctx.fps_replay_fast));
        } else if (ctx.fps_status == 1) {
            ctx.fps_dbl = 1.0 / (repStatus ? 9999.0 : (ctx.fps_replay_fast > 1200 ? 9999.0 : (double)ctx.fps_replay_fast));
        }
    } else if (ctx.fps_status == 2) {
        if (isDebugAccActive) {
            isDebugAccActive = false;
            res = -1;
        }
        if (repStatus) {
            if (!vpFast && Gui::ImplWin32GetKeyFrame(VK_CONTROL)) {
                callback(ctx.fps_replay_fast > 1200 ? 9999 : ctx.fps_replay_fast);
            } else if (!vpSlow && Gui::ImplWin32GetKeyFrame(VK_SHIFT)) {
                callback(ctx.fps_replay_slow);
            } else {
                callback(ctx.fps);
            }
        } else {
            callback(ctx.fps);
        }
    } else if (ctx.fps_status == 1) {
        if (isDebugAccActive) {
            isDebugAccActive = false;
            res = -1;
        }
        if (repStatus) {
            if (Gui::ImplWin32GetKeyFrame(VK_CONTROL)) {
                ctx.fps_dbl = 1.0 / (ctx.fps_replay_fast > 1200 ? 9999.0 : (double)ctx.fps_replay_fast);
            } else if (Gui::ImplWin32GetKeyFrame(VK_SHIFT)) {
                ctx.fps_dbl = 1.0 / (double)ctx.fps_replay_slow;
            } else {
                ctx.fps_dbl = 1.0 / (double)ctx.fps;
            }
        } else {
            ctx.fps_dbl = 1.0 / (double)ctx.fps;
        }
    }
    return res;
}

bool GameFPSOpt(adv_opt_ctx& ctx, bool replay)
{
    static char tmpStr[32] {};
    static int fps = 0;
    static int fpsStatic = 60;
    static int fpsSlowStatic = 0;
    static int fpsFastStatic = 0;
    static int fpsDebugAcc = 0;
    static int fpsMultiplier = 0;
    static bool canFpsChangeFreely = false;
    bool clickedApply = false;
    const char* fpsMultiplierStr;

    if (fps == 0) {
        if (ctx.fps_status == 1) {
            fpsStatic = fps = 60;
            ctx.fps_replay_slow = fpsSlowStatic = 15;
            ctx.fps_replay_fast = 60;
            fpsFastStatic = 1;
            fpsDebugAcc = ctx.fps_debug_acc;
        } else if (ctx.fps_status == 2) {
            fpsStatic = fps = ctx.fps;

            if (fps <= 60)
                fpsStatic = fps = 60;
            else if (fps % 15)
                canFpsChangeFreely = true;
            else
                fpsMultiplier = (fps - 60) / 15;

            if (ctx.fps_replay_slow > 60) {
                ctx.fps_replay_slow = 60;
            }
            fpsSlowStatic = ctx.fps_replay_slow;

            if (ctx.fps_replay_fast < 60) {
                ctx.fps_replay_fast = 60;
            }
            ctx.fps_replay_fast = ctx.fps_replay_fast - ctx.fps_replay_fast % 60;
            fpsFastStatic = ctx.fps_replay_fast / 60;

            fpsDebugAcc = ctx.fps_debug_acc;
        }
    }

    if (ctx.fps_status <= 0) {
        ImGui::PushTextWrapPos();
        if (ctx.fps_status == 0)
            ImGui::TextColored(ImColor(255, 0, 0), "%s", S(TH_FPS_ERR));
        else if (ctx.fps_status == -1)
            ImGui::TextColored(ImColor(255, 0, 0), "%s", S(TH_FPS_UNSUPPORTED));
        ImGui::PopTextWrapPos();
        ImGui::BeginDisabled();
    }

    switch (fpsMultiplier) {
    case 1:
        fpsMultiplierStr = "x1.25 (75fps)";
        break;
    case 2:
        fpsMultiplierStr = "x1.5 (90fps)";
        break;
    case 3:
        fpsMultiplierStr = "x1.75 (105fps)";
        break;
    case 4:
        fpsMultiplierStr = "x2.0 (120fps)";
        break;
    case 5:
        fpsMultiplierStr = "x2.25 (135fps)";
        break;
    case 6:
        fpsMultiplierStr = "x2.5 (150fps)";
        break;
    case 7:
        fpsMultiplierStr = "x2.75 (165fps)";
        break;
    case 8:
        fpsMultiplierStr = "x3.0 (180fps)";
        break;
    default:
        fpsMultiplierStr = "x1.0 (60fps)";
        break;
    }

    ImGui::PushItemWidth(GetRelWidth(0.23f));
    if (canFpsChangeFreely) {
        ImGui::DragInt(S(TH_FPS_ADJ), &fps, 1.0f, 60, 6000);
        if (!ImGui::IsItemActive())
            fps = std::clamp(fps, 60, 6000);
    } else {
        ImGui::SliderInt(S(TH_FPS_ADJ), &fpsMultiplier, 0, 8, fpsMultiplierStr);
        fps = fpsMultiplier * 15 + 60;
    }
    ImGui::PopItemWidth();
    ImGui::SameLine();
    if (ImGui::Checkbox(S(TH_FPS_FREE_ADJ), &canFpsChangeFreely)) {
        if (!canFpsChangeFreely) {
            int i = 0;
            for (; (i * 15 + 60) <= fps && i <= 8; ++i)
                ;
            fpsMultiplier = --i;
            fps = fpsMultiplier * 15 + 60;
        }
    }

    if (replay) {
        ImGui::PushItemWidth(GetRelWidth(0.23f));
        if (fpsFastStatic > 20) {
            sprintf(tmpStr, "infinite");
        } else {
            sprintf(tmpStr, "x%d.0 (%dfps)", fpsFastStatic, fpsFastStatic * 60);
        }

        ImGui::SliderInt("Replay slow FPS", &fpsSlowStatic, 1, 60);
        ImGui::SliderInt("Replay fast FPS", &fpsFastStatic, 1, 21, tmpStr);
        ImGui::PopItemWidth();
    }
    ImGui::Checkbox("Debug acc.", (bool*)&fpsDebugAcc);
    ImGui::SameLine();
    HelpMarker("Blah");

    if (fpsStatic != fps
        || fpsSlowStatic != ctx.fps_replay_slow
        || fpsFastStatic != ctx.fps_replay_fast / 60
        || fpsDebugAcc != ctx.fps_debug_acc) {
        ImGui::SameLine();
        if (ImGui::Button(S(TH_ADV_OPT_APPLY))) {
            clickedApply = true;
            if (fpsStatic > fps && ctx.fps_status != 1)
                ImGui::TextUnformatted(S(TH_FPS_LOWERING));
            fpsStatic = fps;
            ctx.fps_replay_slow = fpsSlowStatic;
            ctx.fps_replay_fast = fpsFastStatic * 60;
            ctx.fps_debug_acc = fpsDebugAcc;
        }
    }

    if (ctx.fps_status <= 0)
        ImGui::EndDisabled();

    ctx.fps = fpsStatic;
    return clickedApply;
}

void DisableKeyOpt()
{
    ImGui::Checkbox(S(TH_ADV_DISABLE_X_KEY), &g_disable_xkey);
    ImGui::SameLine();
    HelpMarker(S(TH_ADV_DISABLE_X_KEY_DESC));
    ImGui::SameLine();
    ImGui::Checkbox(S(TH_ADV_DISABLE_SHIFT_KEY), &g_disable_shiftkey);
    ImGui::SameLine();
    HelpMarker(S(TH_ADV_DISABLE_SHIFT_KEY_DESC));
    ImGui::SameLine();
    ImGui::Checkbox(S(TH_ADV_DISABLE_Z_KEY), &g_disable_zkey);
    ImGui::SameLine();
    if (ImGui::IsKeyDown(0x10))//shift
    {
        if (ImGui::IsKeyPressed('D'))
            g_disable_xkey = !g_disable_xkey;
        if (ImGui::IsKeyPressed('S'))
            g_disable_zkey = !g_disable_zkey;
        if (ImGui::IsKeyPressed('A'))
            g_disable_shiftkey = !g_disable_shiftkey;
    }
    
    HelpMarker(S(TH_ADV_DISABLE_Z_KEY_DESC));
    return;
}

void KeyHUDOpt()
{
    ImGui::Checkbox(S(THPRAC_KB_OPEN), &(g_adv_igi_options.show_keyboard_monitor));
    if (g_adv_igi_options.show_keyboard_monitor){
        
        if (!g_record_key_aps){
            if (ImGui::Button(S(THPRAC_KB_RECORD_START))){
                ClearKeyRecord();
                g_record_key_aps = true;
            }
        }else if (ImGui::Button(S(THPRAC_KB_RECORD_STOP)))
            g_record_key_aps = false;
        ImGui::SameLine();
        if (ImGui::Button(S(THPRAC_KB_OUTPUT))){
            SaveKeyRecorded();
        }
        auto& recorded_aps = GetKeyAPS();
        if (recorded_aps.size() >= 2) {
            ImGui::PlotLines("##APS", 
                [](void* data, int idx) -> float { 
                    std::vector<uint8_t> &recorded_aps = *(std::vector<uint8_t>*)data;
                    if (recorded_aps.size() > 600) 
                        return recorded_aps[recorded_aps.size() - 600 + idx];
                    else return  recorded_aps[idx]; }
                ,&recorded_aps, recorded_aps.size() > 600 ? 600 : recorded_aps.size(), 0, 0, FLT_MAX, FLT_MAX, { 0, ImGui::GetFrameHeight() * 3.0f });
        }
    }
}


bool GameplayOpt(adv_opt_ctx& ctx)
{
    bool hasChanged = false;

    hasChanged |= ImGui::Checkbox(S(TH_FACTOR_ACB), &ctx.all_clear_bonus);
    ImGui::SameLine();
    HelpMarker(S(TH_FACTOR_ACB_DESC));

    return hasChanged;
}

void AboutOpt(const char* thanks_text)
{
    static bool showLicense = false;
    if (BeginOptGroup<TH_ABOUT_THPRAC>()) {
        ImGui::Text(S(TH_ABOUT_VERSION), GetVersionStr());
        ImGui::TextUnformatted(S(TH_ABOUT_AUTHOR));
        ImGui::TextUnformatted(S(TH_ABOUT_WEBSITE));

        ImGui::NewLine();
        ImGui::Text(S(TH_ABOUT_THANKS), thanks_text ? thanks_text : "You!");

        ImGui::NewLine();
        if (showLicense) {
            if (ImGui::Button(S(TH_ABOUT_HIDE_LICENCE)))
                showLicense = false;
        } else {
            if (ImGui::Button(S(TH_ABOUT_SHOW_LICENCE)))
                showLicense = true;
        }
        if (showLicense) {
            ImGui::BeginChild("COPYING", ImVec2(0.0f, GetRelHeight(0.8f)), true);

            Gui::ShowLicenceInfo();

            ImGui::EndChild();
        }

        EndOptGroup();
    }
}

void InfLifeOpt()
{
    ImGui::Checkbox(S(THPRAC_INFLIVES_MAP), &g_adv_igi_options.map_inf_life_to_no_continue);
    return;
}

#pragma endregion

#pragma region Replay System

bool ReplaySaveParam(const wchar_t* rep_path, const std::string& param)
{
    auto repFile = CreateFileW(rep_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (repFile == INVALID_HANDLE_VALUE)
        return false;
    defer(CloseHandle(repFile));
    DWORD repMagic = 0, bytesRead = 0;
    if ((SetFilePointer(repFile, 0, nullptr, FILE_BEGIN) != INVALID_SET_FILE_POINTER) && (ReadFile(repFile, &repMagic, sizeof(LONG), &bytesRead, nullptr))) {
        if (repMagic == 'PR6T' || repMagic == 'PR7T') {
            auto paramSize = param.size();
            for (paramSize++; paramSize % 4; paramSize++)
                ;
            auto paramBuf = malloc(paramSize + 8);
            if (!paramBuf)
                return false;
            defer(free(paramBuf));
            memset(paramBuf, 0, paramSize);
            memcpy(paramBuf, param.data(), param.size());
            *(int32_t*)((int)paramBuf + paramSize) = paramSize;
            *(int32_t*)((int)paramBuf + paramSize + 4) = 'CARP';

            SetFilePointer(repFile, 0, nullptr, FILE_END);
            WriteFile(repFile, paramBuf, paramSize + 8, &bytesRead, nullptr);

            // Recalculate checksum
            auto repSize = GetFileSize(repFile, nullptr);
            uint8_t* repBuf = (uint8_t*)malloc(repSize - (repMagic == 'PR6T' ? 14 : 13));
            if (!repBuf)
                return false;
            defer(free(repBuf));
            SetFilePointer(repFile, repMagic == 'PR6T' ? 14 : 13, nullptr, FILE_BEGIN);
            if (!ReadFile(repFile, repBuf, repSize - (repMagic == 'PR6T' ? 14 : 13), &bytesRead, nullptr))
                return false;

            uint8_t key = *repBuf;
            auto decBuf = repBuf + (repMagic == 'PR6T' ? 1 : 3);
            for (DWORD i = 0; i < repSize - (repMagic == 'PR6T' ? 15 : 16); i++, decBuf++) {
                *decBuf -= key;
                key += 7;
            }

            DWORD checksum = 0x3F000318;
            decBuf = repBuf;
            for (DWORD i = 0; i < repSize - (repMagic == 'PR6T' ? 14 : 13); i++, decBuf++)
                checksum += *decBuf;

            SetFilePointer(repFile, 8, nullptr, FILE_BEGIN);
            WriteFile(repFile, &checksum, 4, &bytesRead, nullptr);
        } else {
            auto paramSize = param.size() + 12;
            for (paramSize++; paramSize % 4; paramSize++)
                ;
            auto paramBuf = malloc(paramSize);
            if (!paramBuf)
                return false;
            defer(free(paramBuf));
            memset(paramBuf, 0, paramSize);
            *(int32_t*)((int)paramBuf) = 'RESU';
            *(int32_t*)((int)paramBuf + 4) = paramSize;
            *(int32_t*)((int)paramBuf + 8) = 'CARP';
            memcpy((void*)((int)paramBuf + 12), param.data(), param.size());

            SetFilePointer(repFile, 0, nullptr, FILE_END);
            WriteFile(repFile, paramBuf, paramSize, &bytesRead, nullptr);
        }
    }
    return false;
}

bool ReplayLoadParam(const wchar_t* rep_path, std::string& param)
{
    DWORD repMagic = 0, bytesRead = 0;

    auto repFile = CreateFileW(rep_path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (repFile == INVALID_HANDLE_VALUE)
        return false;
    defer(CloseHandle(repFile));

    SetFilePointer(repFile, 0, nullptr, FILE_BEGIN);
    if (ReadFile(repFile, &repMagic, 4, &bytesRead, nullptr) && bytesRead == 4) {
        if (repMagic == 'PR6T' || repMagic == 'PR7T') {
            DWORD magic = 0, paramLength = 0;
            DWORD repSize = GetFileSize(repFile, nullptr);

            SetFilePointer(repFile, -4, nullptr, FILE_END);
            if (ReadFile(repFile, &magic, 4, &bytesRead, nullptr) && bytesRead == 4 && magic == 'CARP') {
                SetFilePointer(repFile, -8, nullptr, FILE_CURRENT);
                if (!ReadFile(repFile, &paramLength, 4, &bytesRead, nullptr))
                    return false;

                if (bytesRead == 4 && paramLength > 0 && paramLength < repSize) {
                    SetFilePointer(repFile, ~paramLength - 3, nullptr, FILE_CURRENT);
                    char* buf = (char*)malloc(paramLength + 1);
                    if (!buf)
                        return false;
                    defer(free(buf));
                    memset(buf, 0, paramLength + 1);

                    if (ReadFile(repFile, buf, paramLength, &bytesRead, nullptr) && bytesRead == paramLength)
                        param = std::string(buf, paramLength);

                    return (bytesRead == paramLength);
                }
            }
        } else {
            DWORD userPtr = 0, userMagic = 0, userLength = 0, userNo = 0;

            SetFilePointer(repFile, 12, nullptr, FILE_BEGIN);
            if (ReadFile(repFile, &userPtr, 4, &bytesRead, nullptr) && bytesRead == 4) {
                SetFilePointer(repFile, userPtr, nullptr, FILE_BEGIN);
                while (true) {
                    if (!ReadFile(repFile, &userMagic, 4, &bytesRead, nullptr) || bytesRead != 4 || userMagic != 'RESU')
                        break;
                    if (!ReadFile(repFile, &userLength, 4, &bytesRead, nullptr) || bytesRead != 4)
                        break;
                    if (!ReadFile(repFile, &userNo, 4, &bytesRead, nullptr) || bytesRead != 4)
                        break;

                    if (userNo == 'CARP') {
                        char* buf = (char*)malloc(userLength - 12 + 1);
                        if (!buf)
                            break;
                        defer(free(buf));
                        memset(buf, 0, userLength - 12 + 1);
                        if (ReadFile(repFile, buf, userLength - 12, &bytesRead, nullptr) && bytesRead == userLength - 12)
                            param = std::string((char*)buf, userLength - 12 + 1);

                        return (bytesRead == userLength - 12);
                    } else {
                        SetFilePointer(repFile, userLength - 12, nullptr, FILE_CURRENT);
                    }
                }
            }
        }
    }
    return false;
}

#pragma endregion

#pragma region Virtual File System

void VFile::Write(const char* data)
{
    unsigned int i = 0;
    for (; data[i] != '\0'; i++)
        *(mBuffer + mPos + i) = ((uint8_t*)data)[i];
    mPos += i;
}
void VFile::Write(void* data, unsigned int length)
{
    if (!mBuffer)
        return;
    for (unsigned int i = 0; i < length; i++) {
        if ((mPos + i) >= mSize)
            break;
        *(mBuffer + mPos + i) = ((uint8_t*)data)[i];
    }
    mPos += length;
}
void VFile::Read(void* buffer, unsigned int length)
{
    if (!mBuffer)
        return;
    for (unsigned int i = 0; i < length; i++) {
        if ((mPos + i) >= mSize)
            break;
        ((uint8_t*)buffer)[i] = *(mBuffer + mPos + i);
    }
    mPos += length;
}
#pragma endregion

#pragma region Snapshot
namespace THSnapshot {
    void* GetSnapshotData(IDirect3DDevice8* d3d8)
    {
        IDirect3DSurface8* surface = nullptr;
        d3d8->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &surface);
        D3DLOCKED_RECT rect = {};
        surface->LockRect(&rect, nullptr, 0);

        void* bmp = malloc(0xE2000);
        uint8_t* bmp_write = (uint8_t*)bmp;
        for (int32_t i = 0x1DF; i >= 0; --i) {
            uint8_t* bmp_bits = ((uint8_t*)rect.pBits) + i * rect.Pitch;
            for (size_t j = 0; j < 0x280; ++j) {
                memcpy(bmp_write, bmp_bits, 3); // This *should* get optimized to byte/word MOVs
                bmp_bits += 4;
                bmp_write += 3;
            }
        }

        surface->UnlockRect();
        surface->Release();

        return bmp;
    }
    void Snapshot(IDirect3DDevice8* d3d8)
    {
        wchar_t dir[] = L"snapshot/th000.bmp";
        HANDLE hFile;
        CreateDirectoryW(L"snapshot", nullptr);
        for (int i = 0; i < 1000; i++) {
            dir[13] = static_cast<wchar_t>(i % 10) + L'0';
            dir[12] = static_cast<wchar_t>((i % 100 - i % 10) / 10) + L'0';
            dir[11] = static_cast<wchar_t>((i - i % 100) / 100) + L'0';
            hFile = CreateFileW(dir, GENERIC_READ | GENERIC_WRITE, 0, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);
            if (hFile != INVALID_HANDLE_VALUE)
                break;
        }
        if (hFile == INVALID_HANDLE_VALUE)
            return;

        auto header = "\x42\x4d\x36\x10\x0e\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\xe0\x01\x00\x00\x01\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
        void* bmp = GetSnapshotData(d3d8);
        DWORD bytesRead;
        WriteFile(hFile, header, 0x36, &bytesRead, nullptr);
        WriteFile(hFile, bmp, 0xE2000, &bytesRead, nullptr);
        free(bmp);

        CloseHandle(hFile);
    }
};
#pragma endregion

#pragma region ECL Warp
void StageWarpsRender(stage_warps_t& warps, std::vector<unsigned int>& out_warp, size_t level)
{
    if (warps.section_param.size() == 0)
        return;

    if (out_warp.size() <= level)
        out_warp.resize(level + 1);

    if (warps.section_param.size() <= out_warp[level]) {
        out_warp[level] = warps.section_param.size() - 1;
    }

    switch (warps.type) {
    case stage_warps_t::TYPE_SLIDER:
        ImGui::SliderInt(warps.label, (int*)&out_warp[level], 0, warps.section_param.size() - 1, warps.section_param[out_warp[level]].label);
        break;
    case stage_warps_t::TYPE_COMBO:
        if (ImGui::BeginCombo(warps.label, warps.section_param[out_warp[level]].label)) {
            for (unsigned int i = 0; i < warps.section_param.size(); i++) {
                ImGui::PushID(i);

                bool item_selected = (out_warp[level] == i);

                if (ImGui::Selectable(warps.section_param[i].label, &item_selected)) {
                    out_warp[level] = i;
                }

                if (item_selected)
                    ImGui::SetItemDefaultFocus();

                ImGui::PopID();
            }
            ImGui::EndCombo();
        }
    default:
        break;
    }

    if (ImGui::IsItemFocused()) {
        if (Gui::InGameInputGet(VK_LEFT) && out_warp[level] > 0) {
            out_warp[level]--;
        }
        if (Gui::InGameInputGet(VK_RIGHT) && out_warp[level] + 1 < warps.section_param.size()) {
            out_warp[level]++;
        }
    }

    if (warps.section_param[out_warp[level]].phases) {
        ImGui::PushID(level + 1);
        StageWarpsRender(*warps.section_param[out_warp[level]].phases, out_warp, level + 1);
        ImGui::PopID();
    }
}

uint8_t* ThModern_ECLGetSub(const char* name, uintptr_t param)
{
    struct ecl_sub_t {
        const char* name;
        uint8_t* data;
    };
    auto subs = (ecl_sub_t*)param;

    while (strcmp(subs->name, name))
        subs++;
    return subs->data;
};

void StageWarpsApply(stage_warps_t& warps, std::vector<unsigned int>& in_warp, ecl_get_sub_t* ECLGetSub, uintptr_t ecl_get_sub_param, size_t level)
{
    if (!in_warp.size())
        return;
    auto& param = warps.section_param[in_warp[level]];

    // This entire block gives me the idea to convert everything to writes once there's a JSON
    // file. But for readability, as long as there is no JSON file, this block will have to stay
    for (auto& jumps : param.jumps) {
        uint8_t* ecl = ECLGetSub(jumps.first.c_str(), ecl_get_sub_param);
        for (auto& jmp : jumps.second) {
            ecl_write_t real_write;
            real_write.off = jmp.off;
            union i32b {
                uint32_t i;
                uint8_t b[4];
                i32b(uint32_t a)
                    : i(a)
                {
                }
            };

            i32b ecl_time = jmp.ecl_time;
            uint8_t instr[] = { 0x0c, 0x00, 0x18, 0x00, 0x00, 0x00, 0xff, 0x2c, 0x00, 0x00, 0x00, 0x00 };
            i32b dest = jmp.dest - jmp.off;
            i32b at_frame = jmp.at_frame;

#define BYTES_APPEND(a)                    \
    for (size_t j = 0; j < sizeof(a); j++) \
        real_write.bytes.push_back(a[j]);

            BYTES_APPEND(ecl_time.b);
            BYTES_APPEND(instr);
            BYTES_APPEND(dest.b);
            BYTES_APPEND(at_frame.b);
#undef BYTES_APPEND

            real_write.apply(ecl);
        }
    }

    for (auto& writes : param.writes) {
        uint8_t* ecl = ECLGetSub(writes.first.c_str(), ecl_get_sub_param);
        for (auto& write : writes.second) {
            write.apply(ecl);
        }
    }

    if (param.phases)
        StageWarpsApply(*param.phases, in_warp, ECLGetSub, ecl_get_sub_param, level + 1);
}
#pragma endregion

#pragma region Game State
bool GameState_Assert(bool cond)
{
    if (cond)
        return true;

    int res = MessageBoxW(NULL,
        L"CORRUPT GAME STATE DETECTED!!!\n\n"
        L"Your game will likely crash very soon\n"
        L"Would you like to proceed anyways?",
        L"FATAL ERROR", MB_ICONERROR | MB_YESNO);
    if (res == IDYES)
        return false;
    else
        ExitProcess(UINT_MAX);
}
#pragma endregion

#pragma region SSS
bool g_blind_view = false;
float g_blind_size = 150.0f;
ImTextureID g_blind_texture = NULL;
bool g_is_texture_failed = false;
void RenderBlindView(int dx_ver, DWORD device, ImVec2 plpos, ImVec2 plpos_ofs, ImVec2 stagepos, float zoom)
{
    if (g_blind_view)
    {
        static const char blind_file[] = {
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x08, 0x06, 0x00, 0x00, 0x00, 0xC3, 0x3E, 0x61,
        0xCB, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x16, 0x25, 0x00, 0x00, 0x16,
        0x25, 0x01, 0x49, 0x52, 0x24, 0xF0, 0x00, 0x00, 0x04, 0xEE, 0x69, 0x54, 0x58, 0x74, 0x58, 0x4D,
        0x4C, 0x3A, 0x63, 0x6F, 0x6D, 0x2E, 0x61, 0x64, 0x6F, 0x62, 0x65, 0x2E, 0x78, 0x6D, 0x70, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x3C, 0x3F, 0x78, 0x70, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x20, 0x62, 0x65,
        0x67, 0x69, 0x6E, 0x3D, 0x22, 0xEF, 0xBB, 0xBF, 0x22, 0x20, 0x69, 0x64, 0x3D, 0x22, 0x57, 0x35,
        0x4D, 0x30, 0x4D, 0x70, 0x43, 0x65, 0x68, 0x69, 0x48, 0x7A, 0x72, 0x65, 0x53, 0x7A, 0x4E, 0x54,
        0x63, 0x7A, 0x6B, 0x63, 0x39, 0x64, 0x22, 0x3F, 0x3E, 0x20, 0x3C, 0x78, 0x3A, 0x78, 0x6D, 0x70,
        0x6D, 0x65, 0x74, 0x61, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3A, 0x78, 0x3D, 0x22, 0x61, 0x64,
        0x6F, 0x62, 0x65, 0x3A, 0x6E, 0x73, 0x3A, 0x6D, 0x65, 0x74, 0x61, 0x2F, 0x22, 0x20, 0x78, 0x3A,
        0x78, 0x6D, 0x70, 0x74, 0x6B, 0x3D, 0x22, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x20, 0x58, 0x4D, 0x50,
        0x20, 0x43, 0x6F, 0x72, 0x65, 0x20, 0x39, 0x2E, 0x31, 0x2D, 0x63, 0x30, 0x30, 0x31, 0x20, 0x37,
        0x39, 0x2E, 0x61, 0x38, 0x64, 0x34, 0x37, 0x35, 0x33, 0x2C, 0x20, 0x32, 0x30, 0x32, 0x33, 0x2F,
        0x30, 0x33, 0x2F, 0x32, 0x33, 0x2D, 0x30, 0x38, 0x3A, 0x35, 0x36, 0x3A, 0x33, 0x37, 0x20, 0x20,
        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x3E, 0x20, 0x3C, 0x72, 0x64, 0x66, 0x3A, 0x52, 0x44,
        0x46, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3A, 0x72, 0x64, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74,
        0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x77, 0x33, 0x2E, 0x6F, 0x72, 0x67, 0x2F, 0x31,
        0x39, 0x39, 0x39, 0x2F, 0x30, 0x32, 0x2F, 0x32, 0x32, 0x2D, 0x72, 0x64, 0x66, 0x2D, 0x73, 0x79,
        0x6E, 0x74, 0x61, 0x78, 0x2D, 0x6E, 0x73, 0x23, 0x22, 0x3E, 0x20, 0x3C, 0x72, 0x64, 0x66, 0x3A,
        0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x72, 0x64, 0x66, 0x3A,
        0x61, 0x62, 0x6F, 0x75, 0x74, 0x3D, 0x22, 0x22, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3A, 0x78,
        0x6D, 0x70, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6E, 0x73, 0x2E, 0x61, 0x64,
        0x6F, 0x62, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x78, 0x61, 0x70, 0x2F, 0x31, 0x2E, 0x30, 0x2F,
        0x22, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3A, 0x64, 0x63, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70,
        0x3A, 0x2F, 0x2F, 0x70, 0x75, 0x72, 0x6C, 0x2E, 0x6F, 0x72, 0x67, 0x2F, 0x64, 0x63, 0x2F, 0x65,
        0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2F, 0x31, 0x2E, 0x31, 0x2F, 0x22, 0x20, 0x78, 0x6D,
        0x6C, 0x6E, 0x73, 0x3A, 0x78, 0x6D, 0x70, 0x4D, 0x4D, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3A,
        0x2F, 0x2F, 0x6E, 0x73, 0x2E, 0x61, 0x64, 0x6F, 0x62, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x78,
        0x61, 0x70, 0x2F, 0x31, 0x2E, 0x30, 0x2F, 0x6D, 0x6D, 0x2F, 0x22, 0x20, 0x78, 0x6D, 0x6C, 0x6E,
        0x73, 0x3A, 0x73, 0x74, 0x45, 0x76, 0x74, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
        0x6E, 0x73, 0x2E, 0x61, 0x64, 0x6F, 0x62, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x78, 0x61, 0x70,
        0x2F, 0x31, 0x2E, 0x30, 0x2F, 0x73, 0x54, 0x79, 0x70, 0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75,
        0x72, 0x63, 0x65, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x23, 0x22, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73,
        0x3A, 0x70, 0x68, 0x6F, 0x74, 0x6F, 0x73, 0x68, 0x6F, 0x70, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70,
        0x3A, 0x2F, 0x2F, 0x6E, 0x73, 0x2E, 0x61, 0x64, 0x6F, 0x62, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
        0x70, 0x68, 0x6F, 0x74, 0x6F, 0x73, 0x68, 0x6F, 0x70, 0x2F, 0x31, 0x2E, 0x30, 0x2F, 0x22, 0x20,
        0x78, 0x6D, 0x70, 0x3A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6F, 0x72, 0x54, 0x6F, 0x6F, 0x6C, 0x3D,
        0x22, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x20, 0x50, 0x68, 0x6F, 0x74, 0x6F, 0x73, 0x68, 0x6F, 0x70,
        0x20, 0x32, 0x34, 0x2E, 0x37, 0x20, 0x28, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x29, 0x22,
        0x20, 0x78, 0x6D, 0x70, 0x3A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x61, 0x74, 0x65, 0x3D,
        0x22, 0x32, 0x30, 0x32, 0x35, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x33, 0x54, 0x31, 0x37, 0x3A, 0x35,
        0x33, 0x3A, 0x31, 0x30, 0x2B, 0x30, 0x38, 0x3A, 0x30, 0x30, 0x22, 0x20, 0x78, 0x6D, 0x70, 0x3A,
        0x4D, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x44, 0x61, 0x74, 0x65, 0x3D, 0x22, 0x32, 0x30,
        0x32, 0x35, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x33, 0x54, 0x31, 0x37, 0x3A, 0x35, 0x33, 0x3A, 0x31,
        0x30, 0x2B, 0x30, 0x38, 0x3A, 0x30, 0x30, 0x22, 0x20, 0x78, 0x6D, 0x70, 0x3A, 0x4D, 0x6F, 0x64,
        0x69, 0x66, 0x79, 0x44, 0x61, 0x74, 0x65, 0x3D, 0x22, 0x32, 0x30, 0x32, 0x35, 0x2D, 0x30, 0x33,
        0x2D, 0x32, 0x33, 0x54, 0x31, 0x37, 0x3A, 0x35, 0x33, 0x3A, 0x31, 0x30, 0x2B, 0x30, 0x38, 0x3A,
        0x30, 0x30, 0x22, 0x20, 0x64, 0x63, 0x3A, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x3D, 0x22, 0x69,
        0x6D, 0x61, 0x67, 0x65, 0x2F, 0x70, 0x6E, 0x67, 0x22, 0x20, 0x78, 0x6D, 0x70, 0x4D, 0x4D, 0x3A,
        0x49, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x49, 0x44, 0x3D, 0x22, 0x78, 0x6D, 0x70, 0x2E,
        0x69, 0x69, 0x64, 0x3A, 0x65, 0x63, 0x34, 0x31, 0x65, 0x65, 0x30, 0x63, 0x2D, 0x36, 0x30, 0x38,
        0x39, 0x2D, 0x63, 0x37, 0x34, 0x31, 0x2D, 0x62, 0x30, 0x64, 0x37, 0x2D, 0x35, 0x61, 0x33, 0x34,
        0x31, 0x66, 0x32, 0x35, 0x37, 0x34, 0x36, 0x63, 0x22, 0x20, 0x78, 0x6D, 0x70, 0x4D, 0x4D, 0x3A,
        0x44, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x49, 0x44, 0x3D, 0x22, 0x78, 0x6D, 0x70, 0x2E,
        0x64, 0x69, 0x64, 0x3A, 0x65, 0x63, 0x34, 0x31, 0x65, 0x65, 0x30, 0x63, 0x2D, 0x36, 0x30, 0x38,
        0x39, 0x2D, 0x63, 0x37, 0x34, 0x31, 0x2D, 0x62, 0x30, 0x64, 0x37, 0x2D, 0x35, 0x61, 0x33, 0x34,
        0x31, 0x66, 0x32, 0x35, 0x37, 0x34, 0x36, 0x63, 0x22, 0x20, 0x78, 0x6D, 0x70, 0x4D, 0x4D, 0x3A,
        0x4F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x44, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74,
        0x49, 0x44, 0x3D, 0x22, 0x78, 0x6D, 0x70, 0x2E, 0x64, 0x69, 0x64, 0x3A, 0x65, 0x63, 0x34, 0x31,
        0x65, 0x65, 0x30, 0x63, 0x2D, 0x36, 0x30, 0x38, 0x39, 0x2D, 0x63, 0x37, 0x34, 0x31, 0x2D, 0x62,
        0x30, 0x64, 0x37, 0x2D, 0x35, 0x61, 0x33, 0x34, 0x31, 0x66, 0x32, 0x35, 0x37, 0x34, 0x36, 0x63,
        0x22, 0x20, 0x70, 0x68, 0x6F, 0x74, 0x6F, 0x73, 0x68, 0x6F, 0x70, 0x3A, 0x43, 0x6F, 0x6C, 0x6F,
        0x72, 0x4D, 0x6F, 0x64, 0x65, 0x3D, 0x22, 0x33, 0x22, 0x3E, 0x20, 0x3C, 0x78, 0x6D, 0x70, 0x4D,
        0x4D, 0x3A, 0x48, 0x69, 0x73, 0x74, 0x6F, 0x72, 0x79, 0x3E, 0x20, 0x3C, 0x72, 0x64, 0x66, 0x3A,
        0x53, 0x65, 0x71, 0x3E, 0x20, 0x3C, 0x72, 0x64, 0x66, 0x3A, 0x6C, 0x69, 0x20, 0x73, 0x74, 0x45,
        0x76, 0x74, 0x3A, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22, 0x63, 0x72, 0x65, 0x61, 0x74,
        0x65, 0x64, 0x22, 0x20, 0x73, 0x74, 0x45, 0x76, 0x74, 0x3A, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E,
        0x63, 0x65, 0x49, 0x44, 0x3D, 0x22, 0x78, 0x6D, 0x70, 0x2E, 0x69, 0x69, 0x64, 0x3A, 0x65, 0x63,
        0x34, 0x31, 0x65, 0x65, 0x30, 0x63, 0x2D, 0x36, 0x30, 0x38, 0x39, 0x2D, 0x63, 0x37, 0x34, 0x31,
        0x2D, 0x62, 0x30, 0x64, 0x37, 0x2D, 0x35, 0x61, 0x33, 0x34, 0x31, 0x66, 0x32, 0x35, 0x37, 0x34,
        0x36, 0x63, 0x22, 0x20, 0x73, 0x74, 0x45, 0x76, 0x74, 0x3A, 0x77, 0x68, 0x65, 0x6E, 0x3D, 0x22,
        0x32, 0x30, 0x32, 0x35, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x33, 0x54, 0x31, 0x37, 0x3A, 0x35, 0x33,
        0x3A, 0x31, 0x30, 0x2B, 0x30, 0x38, 0x3A, 0x30, 0x30, 0x22, 0x20, 0x73, 0x74, 0x45, 0x76, 0x74,
        0x3A, 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3D, 0x22,
        0x41, 0x64, 0x6F, 0x62, 0x65, 0x20, 0x50, 0x68, 0x6F, 0x74, 0x6F, 0x73, 0x68, 0x6F, 0x70, 0x20,
        0x32, 0x34, 0x2E, 0x37, 0x20, 0x28, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x29, 0x22, 0x2F,
        0x3E, 0x20, 0x3C, 0x2F, 0x72, 0x64, 0x66, 0x3A, 0x53, 0x65, 0x71, 0x3E, 0x20, 0x3C, 0x2F, 0x78,
        0x6D, 0x70, 0x4D, 0x4D, 0x3A, 0x48, 0x69, 0x73, 0x74, 0x6F, 0x72, 0x79, 0x3E, 0x20, 0x3C, 0x2F,
        0x72, 0x64, 0x66, 0x3A, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x3E,
        0x20, 0x3C, 0x2F, 0x72, 0x64, 0x66, 0x3A, 0x52, 0x44, 0x46, 0x3E, 0x20, 0x3C, 0x2F, 0x78, 0x3A,
        0x78, 0x6D, 0x70, 0x6D, 0x65, 0x74, 0x61, 0x3E, 0x20, 0x3C, 0x3F, 0x78, 0x70, 0x61, 0x63, 0x6B,
        0x65, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x3D, 0x22, 0x72, 0x22, 0x3F, 0x3E, 0xF4, 0x5F, 0x3E, 0x70,
        0x00, 0x00, 0x0C, 0xDD, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED, 0x9D, 0x89, 0x72, 0xDA, 0xCC,
        0x16, 0x84, 0x25, 0x56, 0x1B, 0x3B, 0xC6, 0x76, 0xEE, 0xFB, 0x3F, 0xE1, 0xF5, 0x8E, 0xB1, 0x31,
        0x8B, 0xFE, 0xA4, 0x2A, 0x93, 0xEA, 0xB4, 0xFB, 0xCC, 0x48, 0x62, 0x24, 0x24, 0x34, 0xAA, 0x9A,
        0x12, 0x60, 0xEC, 0x54, 0xE8, 0xEF, 0xF4, 0x59, 0x46, 0x40, 0x9E, 0x65, 0x59, 0x91, 0xA5, 0x63,
        0xB0, 0x47, 0x9E, 0x00, 0x48, 0x00, 0x24, 0x00, 0x12, 0x00, 0xE9, 0x48, 0x00, 0xA4, 0x23, 0x01,
        0x90, 0x8E, 0x04, 0x40, 0x3A, 0x12, 0x00, 0xE9, 0x48, 0x00, 0xA4, 0x23, 0x01, 0x70, 0x46, 0x47,
        0x11, 0xE1, 0x35, 0x4A, 0x00, 0xF4, 0x54, 0xE8, 0xA2, 0x06, 0x10, 0xF9, 0x11, 0x8F, 0x25, 0x00,
        0x4E, 0x28, 0x78, 0x21, 0x1E, 0x2F, 0x4A, 0x3C, 0xDF, 0x12, 0x34, 0x0F, 0xDC, 0xCE, 0xCF, 0x01,
        0x88, 0xBE, 0x01, 0x50, 0x78, 0x04, 0xC7, 0x73, 0x11, 0x78, 0x4E, 0x08, 0x80, 0xDC, 0x73, 0xCE,
        0x03, 0xCF, 0xE9, 0x15, 0x0C, 0x7D, 0x01, 0x20, 0x24, 0xB6, 0xBA, 0xAF, 0x56, 0x95, 0x14, 0x90,
        0x07, 0x56, 0x66, 0xDC, 0xF7, 0xB9, 0x44, 0x02, 0x20, 0x42, 0xB4, 0x5B, 0xEB, 0x60, 0xDC, 0x2E,
        0x0B, 0x42, 0x19, 0xE1, 0x47, 0xC6, 0x6D, 0x1F, 0x20, 0x9D, 0x76, 0x85, 0x2E, 0x02, 0x10, 0x12,
        0x9E, 0x85, 0x3E, 0xC0, 0x63, 0x07, 0xE3, 0x31, 0x7C, 0xBE, 0x72, 0x12, 0x16, 0x4C, 0x09, 0x3D,
        0xA2, 0x95, 0x8B, 0xFB, 0x0A, 0x8C, 0x4E, 0x83, 0xD0, 0x35, 0x00, 0x2C, 0x8B, 0x3F, 0x88, 0xF3,
        0x1E, 0x84, 0xF6, 0xDD, 0x2E, 0x08, 0x88, 0x22, 0x00, 0x40, 0x4E, 0xE2, 0xFE, 0xBE, 0x3D, 0x86,
        0xFB, 0xA1, 0xDB, 0xB9, 0x38, 0x77, 0x36, 0x35, 0x74, 0x05, 0x80, 0x32, 0xC2, 0xB3, 0xC0, 0xFB,
        0x92, 0x4B, 0xB9, 0x42, 0x61, 0xA4, 0x80, 0xDC, 0x88, 0xF6, 0x71, 0xC9, 0xC5, 0x50, 0x74, 0x1E,
        0x84, 0x53, 0x03, 0xC0, 0x76, 0x5F, 0x18, 0xF6, 0x8E, 0xA2, 0xEF, 0xE0, 0xBC, 0x13, 0xF7, 0xF1,
        0x39, 0x0A, 0x84, 0x2A, 0x00, 0xB0, 0xC0, 0x13, 0x38, 0xF3, 0xED, 0x09, 0x3D, 0xC7, 0x82, 0x81,
        0xD3, 0xC3, 0x49, 0x41, 0x38, 0x25, 0x00, 0x85, 0x47, 0xF8, 0xC2, 0x88, 0xE6, 0xDF, 0xC2, 0x6E,
        0x41, 0xEC, 0x2D, 0xDC, 0xDF, 0x12, 0x14, 0x08, 0xC4, 0xC1, 0x80, 0x40, 0x01, 0xC0, 0x96, 0xCE,
        0x22, 0xBB, 0x35, 0x85, 0xF3, 0x54, 0x3C, 0xAE, 0x1C, 0x22, 0xF7, 0x80, 0x90, 0x0F, 0x09, 0x00,
        0xAB, 0xB8, 0x3B, 0x08, 0x7B, 0x67, 0xB1, 0xDD, 0xFA, 0xA2, 0xF3, 0x96, 0x80, 0xB0, 0x20, 0x40,
        0xC8, 0xF8, 0xB5, 0xE0, 0x9C, 0x3F, 0x36, 0x84, 0xC7, 0x35, 0xA3, 0xF3, 0x54, 0x40, 0xC1, 0x69,
        0x62, 0x54, 0xA2, 0x58, 0x3C, 0x4B, 0x00, 0x94, 0xE5, 0x73, 0x8E, 0xDE, 0x51, 0xB4, 0xB3, 0xE8,
        0x9B, 0x3F, 0x67, 0x6B, 0x29, 0x08, 0x62, 0x01, 0x80, 0xA2, 0x5B, 0x6B, 0xEE, 0x81, 0xC1, 0xFD,
        0xBD, 0x91, 0x01, 0x42, 0xEB, 0x29, 0xA1, 0x4D, 0x00, 0x7C, 0x96, 0xAF, 0x6C, 0x7E, 0x4B, 0xC2,
        0x6E, 0x8C, 0xC5, 0x50, 0x28, 0x27, 0xD8, 0xD7, 0x4C, 0x01, 0x63, 0x23, 0xF2, 0x59, 0xEC, 0xB9,
        0xB1, 0x10, 0x8C, 0xA9, 0x91, 0x1E, 0x4E, 0x9A, 0x12, 0xDA, 0x02, 0xC0, 0x67, 0xF9, 0x6C, 0xF5,
        0x4E, 0x44, 0x14, 0xF7, 0x13, 0xCE, 0xB8, 0x18, 0x04, 0x84, 0xC0, 0x81, 0xE4, 0xFE, 0xB6, 0xAF,
        0x13, 0xB0, 0x3A, 0x00, 0x27, 0x16, 0xE6, 0x7B, 0x8E, 0x76, 0xB7, 0x2E, 0x68, 0xCD, 0xE1, 0xEC,
        0x9E, 0xEB, 0x7E, 0x9F, 0x53, 0xC3, 0xC9, 0x52, 0x42, 0x1B, 0x00, 0x58, 0xE2, 0xAB, 0xA8, 0xFF,
        0x12, 0xA2, 0x7F, 0xFC, 0xB9, 0xCD, 0x67, 0x0B, 0x02, 0x2B, 0x05, 0xEC, 0xA9, 0xAD, 0x54, 0x73,
        0x00, 0x6C, 0xDB, 0xC6, 0x81, 0x14, 0x60, 0x89, 0x7F, 0x29, 0xCE, 0x0C, 0xC3, 0xAC, 0xA4, 0x1B,
        0x34, 0x0E, 0x41, 0xD3, 0x00, 0x84, 0xC4, 0xDF, 0x89, 0xFC, 0xBE, 0x01, 0xA1, 0xDD, 0x5A, 0xD3,
        0x7D, 0x86, 0xC0, 0xFD, 0xAE, 0xFB, 0x3B, 0x4A, 0xFC, 0x7D, 0xC5, 0x36, 0x70, 0x6C, 0x40, 0xE0,
        0xC4, 0x73, 0x62, 0xB2, 0xF8, 0xB8, 0x16, 0x74, 0xFF, 0x82, 0xD2, 0x83, 0x4A, 0x0B, 0xAD, 0x42,
        0xD0, 0x24, 0x00, 0x4A, 0xFC, 0x3D, 0x14, 0x7A, 0x28, 0xBE, 0x12, 0x7E, 0x2D, 0x96, 0x82, 0xC0,
        0xB2, 0xFF, 0x5D, 0xE4, 0x39, 0xC0, 0xC4, 0x93, 0x06, 0x2C, 0xF1, 0x79, 0x29, 0x10, 0xB8, 0x63,
        0x18, 0x41, 0xCB, 0xD8, 0x38, 0x04, 0x4D, 0x01, 0x50, 0x56, 0xFC, 0xAF, 0x80, 0xF0, 0xEF, 0xB0,
        0xD6, 0xF0, 0x73, 0x4E, 0x01, 0x75, 0xC4, 0xF7, 0x01, 0x50, 0x05, 0x02, 0x4E, 0x01, 0x0B, 0x00,
        0xE0, 0x0A, 0x96, 0x0F, 0x84, 0xD9, 0xA9, 0x20, 0x68, 0x12, 0x00, 0x65, 0xFB, 0xCA, 0xF2, 0x3F,
        0x41, 0x58, 0x27, 0xF4, 0x8A, 0xC4, 0x77, 0x8B, 0xED, 0x7F, 0x03, 0xD6, 0xBF, 0xA5, 0xA2, 0x6F,
        0xEF, 0x29, 0xFC, 0xCA, 0x00, 0x90, 0x8B, 0x71, 0x30, 0x16, 0x85, 0x53, 0x48, 0x05, 0x73, 0x91,
        0x06, 0xAE, 0xC4, 0xBA, 0x06, 0x30, 0x16, 0x06, 0x04, 0x53, 0x9A, 0x26, 0x5A, 0xD3, 0xC3, 0xCE,
        0x02, 0xE0, 0xFE, 0xDE, 0x41, 0x88, 0xBF, 0x83, 0x68, 0x75, 0x22, 0x72, 0xB4, 0xAF, 0x60, 0xB9,
        0xFB, 0x6B, 0x00, 0x20, 0x86, 0xF8, 0x99, 0x51, 0x04, 0x66, 0x11, 0x21, 0x70, 0x22, 0x5F, 0x83,
        0xF8, 0xD7, 0x70, 0x1F, 0x5D, 0xC1, 0xFD, 0xDE, 0x4C, 0x74, 0x09, 0x58, 0x98, 0x46, 0x77, 0x81,
        0xD8, 0x00, 0xA0, 0xF5, 0x73, 0x9B, 0x87, 0xF9, 0x1E, 0x2D, 0x1F, 0x85, 0x7F, 0xA3, 0xB3, 0x15,
        0xFD, 0x2C, 0xBE, 0xD5, 0xEF, 0xFB, 0x76, 0x00, 0x7D, 0x00, 0x64, 0x01, 0x08, 0xD4, 0x7C, 0x60,
        0x2E, 0xEA, 0x01, 0x8E, 0xFE, 0x1F, 0x74, 0x76, 0x3F, 0xE3, 0x94, 0xE0, 0xFE, 0xA6, 0x6A, 0x13,
        0xA3, 0x42, 0x10, 0x13, 0x00, 0xB5, 0x93, 0x67, 0x45, 0xFE, 0x07, 0x59, 0xBD, 0x13, 0xFC, 0x95,
        0x00, 0x58, 0x51, 0x01, 0x68, 0x89, 0x5F, 0x26, 0xDF, 0xC7, 0xB8, 0x22, 0xC8, 0xAA, 0x0B, 0x2C,
        0x08, 0x16, 0xE0, 0x02, 0x28, 0xFC, 0x0D, 0xDC, 0xC7, 0xD4, 0x70, 0x59, 0xC2, 0x09, 0xA2, 0x42,
        0x10, 0x1B, 0x00, 0x1E, 0xF2, 0x58, 0xE2, 0x73, 0xD4, 0xBF, 0xFD, 0x11, 0xFF, 0x0D, 0xD6, 0x8A,
        0x8A, 0x3F, 0x6C, 0xF9, 0x94, 0xF8, 0xA1, 0xA8, 0xF7, 0x5D, 0x21, 0x6C, 0x5D, 0xF5, 0x5B, 0xC5,
        0x0D, 0x70, 0x46, 0x70, 0x41, 0x10, 0xA0, 0x03, 0xB8, 0x75, 0x03, 0xB7, 0xD9, 0x0D, 0x14, 0x04,
        0xD6, 0xB0, 0xA8, 0x13, 0x00, 0x70, 0xDE, 0xE7, 0x3E, 0x7F, 0x23, 0x22, 0x7F, 0x05, 0xA2, 0xBF,
        0xC2, 0xE2, 0xE8, 0x77, 0xD6, 0x8F, 0xD5, 0xBE, 0x6F, 0xC0, 0x53, 0xF6, 0xA2, 0xD0, 0xB2, 0x2E,
        0xA0, 0x5C, 0xC1, 0x37, 0x30, 0xC2, 0xEE, 0x00, 0x5B, 0x42, 0x74, 0x81, 0x1B, 0x58, 0x3F, 0xC0,
        0x11, 0xAE, 0x45, 0x71, 0xC8, 0x73, 0x82, 0xA8, 0xF5, 0x40, 0x4C, 0x00, 0x38, 0xEF, 0x63, 0xAB,
        0xC7, 0x91, 0x8F, 0x51, 0xFF, 0x42, 0x00, 0xAC, 0x28, 0xFA, 0xD9, 0xF6, 0x59, 0xFC, 0x22, 0x90,
        0xEB, 0xFF, 0xFE, 0xFF, 0x8A, 0x5F, 0x47, 0xA9, 0x17, 0xE5, 0xD7, 0x11, 0x80, 0x21, 0x17, 0x9B,
        0x47, 0x5C, 0x17, 0x60, 0x3A, 0x58, 0x50, 0x21, 0x88, 0x00, 0x2C, 0xC9, 0x0D, 0x94, 0x13, 0x70,
        0x67, 0x30, 0x8A, 0xE5, 0x02, 0x31, 0x00, 0xB0, 0xA6, 0x7C, 0x5B, 0x23, 0xE7, 0x3B, 0xF1, 0x5F,
        0x40, 0xFC, 0x17, 0x8A, 0x7E, 0xB4, 0x7E, 0x4B, 0x7C, 0x5F, 0x85, 0x5F, 0x59, 0xF4, 0x1A, 0x30,
        0x58, 0xB5, 0x81, 0x82, 0x40, 0xA5, 0x02, 0x14, 0x7F, 0xF9, 0x67, 0x61, 0x4A, 0x58, 0x08, 0x08,
        0x7C, 0xD3, 0xC2, 0x93, 0x00, 0xC0, 0x55, 0x3F, 0x57, 0xFC, 0xD8, 0xEA, 0x29, 0xF1, 0x71, 0x61,
        0xEE, 0x57, 0xE2, 0x6F, 0x4B, 0x4C, 0xF5, 0xA2, 0x09, 0x5F, 0x03, 0x04, 0xAE, 0x0B, 0xA6, 0x06,
        0x04, 0x58, 0x0B, 0x2C, 0xC5, 0x62, 0x08, 0x5C, 0x3D, 0x31, 0x35, 0x20, 0x38, 0x2A, 0x15, 0xC4,
        0x00, 0x80, 0xA3, 0x9F, 0xDB, 0xBD, 0x35, 0xD8, 0xFE, 0x2B, 0x08, 0xFE, 0x4C, 0x2E, 0x80, 0xD1,
        0x8F, 0x15, 0x7F, 0x48, 0xFC, 0x46, 0x85, 0xAF, 0x08, 0x82, 0x0F, 0x02, 0x9C, 0x0F, 0xB0, 0x0B,
        0xFC, 0x5E, 0xB7, 0x70, 0xFB, 0x06, 0xD2, 0xC1, 0xC2, 0x68, 0x0F, 0xA3, 0xB8, 0xC0, 0x31, 0x00,
        0xA8, 0xE8, 0xE7, 0xBC, 0xBF, 0x86, 0x6A, 0xDF, 0xE5, 0xF8, 0x67, 0x58, 0x08, 0x80, 0xCA, 0xFB,
        0x58, 0xF0, 0xE1, 0x05, 0x1D, 0xDF, 0x86, 0x3A, 0x4D, 0x0B, 0x5F, 0x02, 0x04, 0x5C, 0x4E, 0x20,
        0x2C, 0x0C, 0x55, 0x3D, 0xC0, 0x00, 0xB8, 0x75, 0x03, 0x85, 0x21, 0x42, 0x30, 0x33, 0x26, 0x85,
        0xB5, 0x5D, 0xE0, 0x58, 0x00, 0x0A, 0xAA, 0xFA, 0xD1, 0xFA, 0x31, 0xEF, 0x73, 0xE4, 0xE3, 0x7A,
        0x25, 0xEB, 0xC7, 0x76, 0x8F, 0x73, 0xFE, 0xB7, 0xAD, 0xDC, 0xB6, 0x85, 0xF7, 0x80, 0x60, 0x6D,
        0x29, 0x23, 0x04, 0xB8, 0x5F, 0x80, 0x2E, 0x70, 0x4B, 0x0B, 0x9D, 0x80, 0xEB, 0x01, 0x4E, 0x05,
        0x47, 0xB9, 0x40, 0x0C, 0x00, 0x30, 0xFA, 0x5D, 0x9B, 0x86, 0xB3, 0x7D, 0x15, 0xF9, 0x4F, 0x46,
        0xF4, 0x7F, 0x50, 0xAF, 0xBF, 0x33, 0xDA, 0xBC, 0xAC, 0x0B, 0xE2, 0x7B, 0xDC, 0x40, 0x41, 0x80,
        0x33, 0x82, 0x4B, 0xC3, 0x05, 0xEE, 0x0C, 0x27, 0xC0, 0xBD, 0x03, 0x9C, 0x0F, 0x8C, 0x8F, 0xED,
        0x08, 0xEA, 0x02, 0x60, 0x45, 0xBF, 0xDB, 0xE0, 0xE1, 0xBC, 0x8F, 0xC2, 0x5B, 0xD1, 0xEF, 0xFA,
        0x7D, 0xEC, 0xF5, 0xA5, 0xF8, 0x5D, 0x11, 0x3E, 0xE0, 0x06, 0x0A, 0x02, 0x27, 0x9E, 0x9B, 0x0F,
        0x58, 0x2E, 0x70, 0x47, 0x10, 0x60, 0x3D, 0x30, 0x17, 0x5D, 0x41, 0x6D, 0x17, 0x38, 0x16, 0x80,
        0x83, 0x18, 0xF8, 0xB8, 0xE8, 0x77, 0x55, 0x3D, 0x8A, 0xFF, 0x04, 0x10, 0xBC, 0x8A, 0xE8, 0xDF,
        0x90, 0xF8, 0xFB, 0xBE, 0x88, 0x1F, 0x80, 0x60, 0x4C, 0x10, 0xCC, 0x85, 0x0B, 0xDC, 0x80, 0xF8,
        0x77, 0x04, 0x81, 0xEB, 0x0C, 0x9C, 0x0B, 0xCC, 0x3D, 0xBB, 0x86, 0x8D, 0x03, 0xC0, 0x95, 0x3F,
        0x8E, 0x7B, 0x3F, 0x0D, 0xEB, 0x7F, 0x32, 0x00, 0xC0, 0xE8, 0x57, 0xD6, 0xDF, 0x2B, 0xF1, 0x4B,
        0x40, 0xA0, 0x52, 0x01, 0xBB, 0xC0, 0x9D, 0x80, 0x80, 0x53, 0xC1, 0x85, 0x18, 0x13, 0xD7, 0x72,
        0x81, 0x63, 0x00, 0xC0, 0xBE, 0xFF, 0x4B, 0x44, 0xBF, 0x2B, 0xFC, 0x50, 0xF8, 0x47, 0xA8, 0xFE,
        0x39, 0xFA, 0x95, 0xF5, 0xF7, 0x4E, 0x7C, 0x0F, 0x04, 0x56, 0x2A, 0xE0, 0x5A, 0xE0, 0xB7, 0xE0,
        0xF7, 0x04, 0x01, 0xB6, 0x86, 0xE8, 0x02, 0x33, 0x63, 0x38, 0xD4, 0x38, 0x00, 0x07, 0x51, 0xFC,
        0x71, 0xF4, 0xBF, 0x40, 0xF4, 0x3F, 0x52, 0xF4, 0xBF, 0x78, 0xA2, 0x7F, 0xCF, 0xED, 0x5E, 0xDF,
        0xC4, 0x27, 0x08, 0xB8, 0x3D, 0x1C, 0x7B, 0x5C, 0x60, 0x49, 0x2E, 0x70, 0x0F, 0x2E, 0xB0, 0xF4,
        0xB8, 0x80, 0xDA, 0x32, 0x6E, 0x04, 0x00, 0x55, 0xFC, 0x71, 0xE5, 0xFF, 0x26, 0xAC, 0xFF, 0x11,
        0xA2, 0x1F, 0xED, 0x1F, 0x27, 0x7E, 0xAA, 0xEA, 0xEF, 0x65, 0xF4, 0x1B, 0x2E, 0xA0, 0xBA, 0x02,
        0x9C, 0x10, 0x72, 0x31, 0x78, 0x4F, 0x4E, 0x70, 0x2B, 0x5C, 0x60, 0x46, 0x2E, 0x50, 0x39, 0x0D,
        0xD4, 0x05, 0x80, 0xA3, 0x9F, 0x2B, 0xFF, 0x17, 0x21, 0x3E, 0xDB, 0x3F, 0x0E, 0x7D, 0x30, 0xFA,
        0x7B, 0x6D, 0xFD, 0x15, 0x52, 0x01, 0xBA, 0x80, 0x1B, 0x0E, 0x71, 0x1A, 0x60, 0x08, 0x96, 0x46,
        0x47, 0x50, 0xBB, 0x18, 0xAC, 0x03, 0xC0, 0x81, 0xC6, 0xBE, 0xCE, 0xFE, 0xDF, 0x69, 0xE8, 0x83,
        0xE2, 0x3F, 0x90, 0xFD, 0xAB, 0xCA, 0xFF, 0xDB, 0xA5, 0xDB, 0x7D, 0x17, 0xDF, 0x48, 0x05, 0x38,
        0x2A, 0x56, 0x1D, 0x01, 0xA6, 0x81, 0x9F, 0x04, 0xC1, 0x92, 0x26, 0x84, 0xBC, 0x51, 0x54, 0x39,
        0x0D, 0xD4, 0x05, 0x80, 0x8B, 0xBF, 0x4F, 0x8A, 0xFE, 0x67, 0x8A, 0xFC, 0x47, 0xAA, 0xFE, 0x57,
        0x34, 0xF2, 0x3D, 0xCB, 0xE8, 0x2F, 0xE9, 0x02, 0x73, 0x9A, 0x0E, 0x62, 0x37, 0x70, 0x4F, 0xEB,
        0x96, 0x5C, 0xE0, 0xC2, 0x53, 0x0C, 0x46, 0x07, 0x80, 0xF7, 0xFC, 0x79, 0xEC, 0xEB, 0x8B, 0x7E,
        0xCC, 0xFF, 0x58, 0xFC, 0x6D, 0x8C, 0xA1, 0xCF, 0xD9, 0x44, 0x7F, 0xC0, 0x05, 0x78, 0x2E, 0xE0,
        0x8A, 0x41, 0xAC, 0x03, 0x7C, 0x2E, 0xC0, 0xE3, 0xE1, 0xCA, 0xD7, 0x0A, 0xD4, 0x05, 0x80, 0xED,
        0x9F, 0x8B, 0xBF, 0x47, 0x61, 0xFF, 0x4F, 0x50, 0xFD, 0xAB, 0xE2, 0xEF, 0x2C, 0xA3, 0x3F, 0xE0,
        0x02, 0x56, 0x31, 0xB8, 0x84, 0xBC, 0xFF, 0x53, 0xB8, 0x00, 0x16, 0x83, 0x2A, 0x0D, 0x34, 0x06,
        0x00, 0xE7, 0x7F, 0xEE, 0xFD, 0xAD, 0xE8, 0x7F, 0x24, 0xFB, 0x7F, 0x37, 0x8A, 0xBF, 0xB3, 0x8C,
        0xFE, 0x80, 0x0B, 0x60, 0x31, 0x78, 0x45, 0x69, 0xE0, 0xDE, 0xE3, 0x02, 0x6A, 0x32, 0x58, 0xB9,
        0x0E, 0xA8, 0x03, 0x80, 0x1A, 0xFE, 0xBC, 0x93, 0xFD, 0x3F, 0x10, 0x00, 0x2A, 0xFF, 0xB3, 0xFD,
        0xFF, 0xDD, 0xE9, 0x3B, 0x73, 0x00, 0x32, 0x31, 0x1D, 0x74, 0x69, 0xC0, 0xAA, 0x03, 0x7E, 0xC2,
        0xF9, 0x8E, 0x66, 0x02, 0x97, 0xC7, 0xD4, 0x01, 0x75, 0x01, 0xC0, 0xE1, 0x0F, 0xE6, 0xFF, 0x67,
        0x00, 0xE0, 0x41, 0x14, 0x80, 0x9C, 0xFF, 0xBF, 0xD9, 0xFF, 0xB9, 0x8A, 0x2F, 0x5C, 0xC0, 0x4A,
        0x03, 0x58, 0x07, 0xDC, 0x91, 0x0B, 0xFC, 0xA4, 0x99, 0x00, 0xD6, 0x01, 0xAA, 0x1D, 0x8C, 0x0A,
        0x80, 0x35, 0xFD, 0xC3, 0xF6, 0xEF, 0x89, 0x00, 0x50, 0xF9, 0x1F, 0xDB, 0x3F, 0xBC, 0xD8, 0xA3,
        0x18, 0x18, 0x00, 0x79, 0xF6, 0xEF, 0x45, 0x23, 0xD8, 0x0E, 0xAA, 0x3A, 0x00, 0x01, 0xB8, 0x33,
        0xDA, 0x41, 0x9E, 0x0A, 0x46, 0x03, 0xC0, 0x2A, 0x00, 0xAD, 0xFC, 0xFF, 0x20, 0xF2, 0x3F, 0x17,
        0x80, 0xDF, 0xE6, 0xFE, 0xE7, 0x2E, 0x3E, 0x41, 0xA0, 0xF6, 0x07, 0xB8, 0x10, 0xBC, 0x15, 0x0E,
        0x60, 0xD5, 0x01, 0xB5, 0x0A, 0xC1, 0x3A, 0x00, 0xEC, 0x08, 0x00, 0xD7, 0xFF, 0xBB, 0x36, 0xEF,
        0x41, 0x38, 0x00, 0x0E, 0x80, 0x70, 0xFA, 0xF7, 0x4F, 0xFB, 0x37, 0x30, 0x00, 0x54, 0x3B, 0x88,
        0xF3, 0x00, 0x1E, 0x08, 0xE1, 0x72, 0x6D, 0xE2, 0x0F, 0xA8, 0x03, 0xF0, 0x72, 0xB1, 0xC6, 0x00,
        0x50, 0xF3, 0xFF, 0x15, 0x00, 0x80, 0x0E, 0xF0, 0x7F, 0xA3, 0x03, 0xF8, 0x10, 0x00, 0x14, 0x03,
        0x05, 0x20, 0x17, 0x00, 0x5C, 0x1A, 0x9D, 0xC0, 0xFF, 0xC8, 0x01, 0x1C, 0x00, 0xD7, 0x81, 0x7D,
        0x81, 0xE8, 0x00, 0xE0, 0xC5, 0x1F, 0xB8, 0xFB, 0xF7, 0x2C, 0xF2, 0x3F, 0x03, 0x80, 0x97, 0x7D,
        0xFD, 0xB3, 0xF9, 0x33, 0x14, 0xF1, 0x45, 0x1A, 0xC0, 0xCD, 0x21, 0xBC, 0x5C, 0xEC, 0xC6, 0x48,
        0x01, 0x5C, 0x08, 0xE2, 0xBE, 0x00, 0x5E, 0x24, 0x12, 0x1D, 0x00, 0x7C, 0xBF, 0x1F, 0xB6, 0x80,
        0x2B, 0x31, 0x00, 0x42, 0x07, 0x78, 0x0A, 0x00, 0x70, 0x18, 0x38, 0x00, 0xA3, 0x00, 0x00, 0x77,
        0xC2, 0x01, 0xEE, 0x45, 0x27, 0x80, 0x1B, 0x43, 0xA5, 0x67, 0x01, 0xC7, 0x02, 0xB0, 0x16, 0x00,
        0x28, 0x07, 0x78, 0x21, 0x00, 0x36, 0x09, 0x80, 0xDC, 0xD7, 0x0A, 0xE2, 0xCE, 0xA0, 0x72, 0x00,
        0x06, 0x60, 0xD1, 0x16, 0x00, 0x98, 0x02, 0x70, 0x06, 0xF0, 0xE2, 0x01, 0x40, 0x39, 0xC0, 0x57,
        0x02, 0x40, 0x02, 0x30, 0xF3, 0x38, 0x80, 0x02, 0x60, 0x99, 0x7D, 0xDF, 0x13, 0xA8, 0x34, 0x0B,
        0x38, 0x16, 0x80, 0x90, 0x03, 0x3C, 0xC0, 0x0C, 0x40, 0x39, 0xC0, 0xDF, 0xAB, 0x7F, 0x06, 0x0A,
        0x00, 0x5F, 0x25, 0xA4, 0x1C, 0x40, 0x75, 0x01, 0xCA, 0x01, 0x12, 0x00, 0x09, 0x80, 0xF6, 0x01,
        0x48, 0x29, 0x60, 0x60, 0x29, 0x20, 0x15, 0x81, 0x03, 0x2F, 0x02, 0x53, 0x1B, 0x38, 0xE0, 0x36,
        0x30, 0x0D, 0x82, 0x06, 0x3E, 0x08, 0x4A, 0xA3, 0xE0, 0x34, 0x0A, 0x4E, 0x9B, 0x41, 0x91, 0x01,
        0xE8, 0xDD, 0x66, 0x50, 0xDA, 0x0E, 0x8E, 0x9F, 0xFF, 0x7B, 0xB1, 0x1D, 0x9C, 0x65, 0xE9, 0x82,
        0x90, 0x26, 0xEC, 0xBF, 0x37, 0x17, 0x84, 0xA8, 0x59, 0x40, 0xBA, 0x24, 0xEC, 0x78, 0xFB, 0xEF,
        0xD5, 0x25, 0x61, 0xE9, 0xA2, 0xD0, 0x38, 0xE2, 0x67, 0x59, 0xCF, 0x2F, 0x0A, 0x4D, 0x97, 0x85,
        0xC7, 0xB3, 0xFF, 0xDE, 0x5D, 0x16, 0x9E, 0xDE, 0x18, 0x72, 0x7C, 0xF4, 0xF7, 0xFA, 0x8D, 0x21,
        0xE9, 0xAD, 0x61, 0x71, 0xA3, 0xBF, 0x57, 0x6F, 0x0D, 0xF3, 0xD5, 0x01, 0xE9, 0xCD, 0xA1, 0xD5,
        0xA3, 0xBF, 0x77, 0x6F, 0x0E, 0xB5, 0xEA, 0x80, 0xF4, 0xF6, 0xF0, 0x7A, 0xD1, 0xDF, 0xDB, 0xB7,
        0x87, 0xA7, 0x0F, 0x88, 0x88, 0x17, 0xFD, 0xBD, 0xFC, 0x80, 0x88, 0xF4, 0x11, 0x31, 0xF5, 0xC4,
        0x3F, 0x8B, 0x8F, 0x88, 0x51, 0x69, 0x20, 0x7D, 0x48, 0x54, 0x39, 0xEB, 0x3F, 0x8B, 0x0F, 0x89,
        0x52, 0x69, 0x20, 0x7D, 0x4C, 0x5C, 0x35, 0xEB, 0x3F, 0x8B, 0x8F, 0x89, 0x4B, 0x1F, 0x14, 0x59,
        0x4D, 0xFC, 0xB3, 0xFA, 0xA0, 0x48, 0xAB, 0x18, 0x4C, 0x1F, 0x15, 0x9B, 0x0D, 0xE3, 0xA3, 0x62,
        0xAD, 0x62, 0x30, 0x7D, 0x58, 0xF4, 0x80, 0x3E, 0x2C, 0xDA, 0xD7, 0x12, 0xA6, 0x8F, 0x8B, 0x1F,
        0xC0, 0xC7, 0xC5, 0xFB, 0x5C, 0x20, 0x7D, 0x61, 0xC4, 0x80, 0xBE, 0x30, 0x22, 0xCB, 0xD2, 0x57,
        0xC6, 0x64, 0xD9, 0x40, 0xBF, 0x32, 0x46, 0x75, 0x04, 0xE9, 0x4B, 0xA3, 0x06, 0xF4, 0xA5, 0x51,
        0x96, 0x0B, 0xA4, 0xAF, 0x8D, 0x1B, 0xD0, 0xD7, 0xC6, 0x59, 0x2E, 0x90, 0xBE, 0x38, 0x72, 0x20,
        0x5F, 0x1C, 0xA9, 0x3A, 0x82, 0xF4, 0xD5, 0xB1, 0x03, 0xFB, 0xEA, 0x58, 0x7C, 0x91, 0xD3, 0x97,
        0x47, 0x0F, 0xF4, 0xCB, 0xA3, 0x55, 0x2A, 0x48, 0x5F, 0x1F, 0x3F, 0xA0, 0xAF, 0x8F, 0xCF, 0xC4,
        0x8B, 0x8D, 0xA9, 0x40, 0x41, 0xB0, 0x06, 0x91, 0xDF, 0xC0, 0x11, 0x56, 0xC2, 0x05, 0xD6, 0xD4,
        0x19, 0x6C, 0x0C, 0x08, 0x7C, 0xB5, 0x41, 0x59, 0x17, 0xB0, 0xF2, 0xBC, 0x2A, 0xF4, 0x58, 0xFC,
        0x39, 0x55, 0xFC, 0x0B, 0x11, 0xFD, 0xD7, 0x10, 0xF1, 0x3F, 0x00, 0x8E, 0x85, 0x47, 0x7C, 0x35,
        0xF0, 0xE9, 0x1C, 0x00, 0xAA, 0x2B, 0x50, 0x9D, 0x01, 0xA6, 0x03, 0xE5, 0x06, 0x2B, 0x72, 0x80,
        0x77, 0x68, 0x0D, 0x7D, 0x10, 0x54, 0x71, 0x03, 0x9F, 0x03, 0x54, 0x89, 0x7A, 0x9F, 0xF8, 0x97,
        0x10, 0xD5, 0x57, 0x04, 0x80, 0x8A, 0xFA, 0x4B, 0xA3, 0xDD, 0x53, 0x5B, 0xBD, 0x79, 0x2C, 0xC1,
        0x62, 0x03, 0xA0, 0xEA, 0x01, 0x9F, 0x13, 0x7C, 0x42, 0x84, 0x23, 0x08, 0x58, 0x08, 0xAE, 0xE0,
        0xE7, 0x98, 0x0A, 0x18, 0x82, 0x2D, 0xFC, 0x3B, 0x3E, 0x08, 0xCA, 0x00, 0xE0, 0x13, 0x7F, 0x42,
        0x6D, 0x1E, 0x8B, 0x8F, 0xFD, 0xFE, 0x02, 0x84, 0xBE, 0x86, 0x75, 0x05, 0x3F, 0xC7, 0x56, 0xCF,
        0x17, 0xF9, 0xA3, 0xD8, 0xE2, 0x37, 0x05, 0x40, 0x26, 0x5E, 0x70, 0xEE, 0x0C, 0x70, 0xE3, 0xE8,
        0x93, 0xF6, 0x0E, 0xD6, 0x22, 0xFA, 0x95, 0x0B, 0x1C, 0x0B, 0x41, 0x61, 0xE4, 0xFC, 0x18, 0xE2,
        0x73, 0xF4, 0x5F, 0x91, 0xD5, 0x5F, 0x89, 0x62, 0x6F, 0x06, 0x7F, 0x73, 0x62, 0xB4, 0x7B, 0x79,
        0x6C, 0xA1, 0x9A, 0x04, 0x40, 0xED, 0x17, 0x60, 0x61, 0xA8, 0x20, 0xF8, 0x00, 0x47, 0x58, 0x93,
        0xF8, 0x6B, 0xF8, 0xF9, 0x27, 0x41, 0xF0, 0x45, 0x1B, 0x48, 0x65, 0xEB, 0x82, 0xAC, 0x44, 0xE4,
        0x8F, 0x0D, 0xDB, 0x9F, 0xD1, 0x88, 0x17, 0xE7, 0xFC, 0x58, 0xFC, 0x71, 0xB4, 0x2F, 0x84, 0xE5,
        0x63, 0xAB, 0x37, 0x81, 0x7F, 0x37, 0x6F, 0x22, 0xEF, 0xB7, 0x01, 0x40, 0x15, 0x08, 0xB6, 0x10,
        0xC9, 0x16, 0x08, 0x6B, 0x6A, 0x09, 0xB9, 0x1E, 0xF8, 0xAA, 0x09, 0x81, 0x05, 0x40, 0x59, 0xF1,
        0x67, 0x22, 0xEF, 0x5F, 0x52, 0x01, 0xE8, 0x13, 0x7E, 0x4E, 0x51, 0xDF, 0xAA, 0xF8, 0x4D, 0x03,
        0x60, 0x41, 0x70, 0x10, 0x73, 0x02, 0x74, 0x03, 0x06, 0xE1, 0xC3, 0x23, 0x3E, 0xB6, 0x86, 0x1B,
        0xF8, 0x3B, 0x3B, 0x0F, 0x04, 0x65, 0x01, 0x50, 0xE2, 0x4F, 0x20, 0x5A, 0xE7, 0xD4, 0xF2, 0x59,
        0x10, 0x5C, 0x1A, 0xC2, 0x2B, 0xCB, 0xB7, 0xA6, 0x7C, 0x79, 0x53, 0x02, 0x35, 0x0D, 0x40, 0x19,
        0x08, 0x78, 0x6A, 0x88, 0x69, 0x61, 0x03, 0x62, 0xF3, 0x99, 0xEB, 0x80, 0x8D, 0x98, 0x11, 0xF8,
        0x06, 0x46, 0xAA, 0x08, 0xF4, 0x0D, 0x78, 0xB8, 0xD7, 0x9F, 0x8B, 0xFC, 0x7F, 0x01, 0x42, 0xE3,
        0x79, 0x4E, 0x76, 0x3F, 0x13, 0xC2, 0xB7, 0x2E, 0x7E, 0x5B, 0x00, 0xF8, 0x20, 0x60, 0x37, 0xD8,
        0x81, 0x88, 0x1B, 0x01, 0xC3, 0x67, 0x40, 0x7C, 0x4E, 0x03, 0x58, 0x14, 0xFA, 0x5A, 0x43, 0xAB,
        0xF0, 0xC3, 0xA2, 0xCF, 0xB2, 0x7F, 0x05, 0xC1, 0x85, 0x10, 0x7D, 0x0E, 0xBF, 0x3F, 0x11, 0x51,
        0xDF, 0xBA, 0xF8, 0x6D, 0x02, 0x60, 0x41, 0xE0, 0x73, 0x83, 0x2D, 0x89, 0xBA, 0x31, 0xD6, 0x97,
        0x28, 0x04, 0x43, 0xF3, 0x01, 0x5F, 0x0A, 0x08, 0xF5, 0xFB, 0x5C, 0x00, 0x32, 0x08, 0x73, 0xB2,
        0xF9, 0x99, 0xC7, 0xEE, 0x7D, 0x95, 0x7E, 0xDE, 0x86, 0x28, 0x6D, 0x02, 0xA0, 0x86, 0x30, 0x05,
        0x45, 0xE6, 0x01, 0x04, 0xDB, 0x91, 0x98, 0x5B, 0x21, 0xB6, 0x5A, 0x56, 0x0A, 0x38, 0x88, 0xCD,
        0x23, 0x7E, 0x2D, 0x70, 0x73, 0x67, 0x14, 0x48, 0x01, 0xD6, 0xE2, 0xFC, 0xCE, 0xC2, 0x4F, 0xC8,
        0x65, 0xD4, 0xC6, 0x4E, 0xDE, 0x96, 0x20, 0x6D, 0x03, 0x50, 0x26, 0x25, 0x28, 0x47, 0xB0, 0x60,
        0xD8, 0x8A, 0xA8, 0x67, 0xF1, 0x63, 0x02, 0x30, 0x11, 0xC2, 0xCE, 0xE8, 0x3C, 0x15, 0x95, 0xFD,
        0x58, 0xD8, 0xFD, 0xE8, 0x54, 0x51, 0xDF, 0x05, 0x00, 0x42, 0x29, 0xA1, 0x20, 0x08, 0x38, 0x3D,
        0x30, 0x14, 0x3B, 0x43, 0x78, 0x16, 0xBF, 0x6A, 0x0A, 0xB0, 0x20, 0x98, 0x50, 0x5D, 0x30, 0x15,
        0x8F, 0x8F, 0xC5, 0xCA, 0x4F, 0x6D, 0xF9, 0x5D, 0x02, 0xC0, 0x4A, 0x09, 0x96, 0x23, 0x1C, 0x68,
        0xCA, 0xC7, 0x22, 0xF3, 0xED, 0x7D, 0xE4, 0x39, 0xC0, 0x98, 0x6C, 0x7C, 0x22, 0xE0, 0x18, 0xD3,
        0x14, 0xCF, 0x17, 0xF1, 0x27, 0xB1, 0xFC, 0xAE, 0x01, 0xA0, 0xDC, 0x20, 0x13, 0x6E, 0x60, 0xC1,
        0x50, 0x66, 0x1D, 0x02, 0x1D, 0x40, 0x16, 0xE8, 0x04, 0x46, 0x46, 0x34, 0xAB, 0x65, 0x89, 0x6E,
        0xED, 0xE4, 0xE5, 0xA7, 0x7E, 0xE1, 0xBB, 0x02, 0x40, 0x15, 0x10, 0x0A, 0x61, 0xE9, 0xBE, 0xDB,
        0x45, 0x89, 0x9D, 0x41, 0xDF, 0x0E, 0x60, 0x4E, 0xA2, 0x86, 0x6E, 0xE7, 0x7D, 0x10, 0xBE, 0xAB,
        0x00, 0xA8, 0xB4, 0x90, 0x19, 0x35, 0x42, 0x21, 0x22, 0xFB, 0x60, 0x3C, 0x56, 0x18, 0x03, 0xA0,
        0xC2, 0x10, 0x66, 0x94, 0xE9, 0xAB, 0x7F, 0x54, 0x64, 0x8F, 0x8C, 0xE7, 0x5B, 0xF9, 0x3D, 0xEF,
        0xD2, 0x8B, 0xDD, 0x45, 0x00, 0xCA, 0x82, 0x50, 0x04, 0xC0, 0xF0, 0x3D, 0x37, 0x33, 0x52, 0x80,
        0xDA, 0x14, 0xCA, 0x0D, 0x71, 0x47, 0x81, 0xE7, 0x76, 0x5A, 0xF8, 0x3E, 0x00, 0x10, 0x4A, 0x0D,
        0x59, 0x66, 0x5F, 0xFA, 0x55, 0x45, 0xF8, 0xAC, 0x06, 0x08, 0xEA, 0x39, 0x59, 0x97, 0xAD, 0xBE,
        0xEF, 0x00, 0x84, 0x5C, 0x41, 0x41, 0xE1, 0x7B, 0x8E, 0xCF, 0x01, 0xB2, 0x2C, 0x7C, 0x51, 0x68,
        0x48, 0xEC, 0xBC, 0x2F, 0x2F, 0x68, 0xDF, 0x00, 0xC8, 0x3C, 0x02, 0x86, 0x44, 0x2E, 0x02, 0xBF,
        0x9F, 0x97, 0x00, 0xC2, 0x17, 0xDD, 0x79, 0x1F, 0x5F, 0xC4, 0x3E, 0x03, 0x10, 0x02, 0xA2, 0xCA,
        0x63, 0x21, 0x21, 0xCB, 0x3E, 0x96, 0x00, 0xE8, 0x09, 0x18, 0x55, 0x5F, 0xA3, 0xB3, 0x3D, 0x86,
        0x00, 0x40, 0x3A, 0x12, 0x00, 0xE9, 0x48, 0x00, 0xA4, 0x23, 0x01, 0x90, 0x8E, 0x04, 0x40, 0x3A,
        0x12, 0x00, 0xE9, 0x48, 0x00, 0xA4, 0x23, 0x01, 0x90, 0x8E, 0x04, 0x40, 0x3A, 0x7E, 0x1D, 0xFF,
        0x01, 0xCC, 0x38, 0xF6, 0xC4, 0xD5, 0xBD, 0x3A, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
        0x44, 0xAE, 0x42, 0x60, 0x82
    };
        ImVec2 texture_size = { 128.0f, 128.0f };
        auto p = ImGui::GetBackgroundDrawList();
        if (!g_blind_texture && !g_is_texture_failed) {
            g_blind_texture = ReadImage(dx_ver, device, "blind.png", blind_file, sizeof(blind_file));
            if (!g_blind_texture)
                g_is_texture_failed = true;
        }
        plpos.x += plpos_ofs.x;
        plpos.y += plpos_ofs.y;
        if (g_blind_texture) {
            p->PushClipRect({ 32.0f * zoom, 16.0f * zoom }, { 416.0f * zoom, 464.0f * zoom });
            float szy = g_blind_size / 80.0f * texture_size.y * 0.5f * 2.0f;
            float szx = g_blind_size / 80.0f * texture_size.x * 0.5f * 2.0f;
            ImVec2 p1 = { (plpos.x + stagepos.x - szx) * zoom, (plpos.y + stagepos.y - szy) * zoom };
            ImVec2 p2 = { (plpos.x + stagepos.x + szx) * zoom, (plpos.y + stagepos.y + szy) * zoom };
            p->AddImage((ImTextureID)g_blind_texture, p1, p2);
            p->AddRectFilled({ -1000.0f, -1000.0f }, { 1000.0f, p1.y }, 0xFF000000);
            p->AddRectFilled({ -1000.0f, -1000.0f }, { p1.x, 1000.0f }, 0xFF000000);
            p->AddRectFilled({ p2.x, -1000.0f }, { 1000.0f, 1000.0f }, 0xFF000000);
            p->AddRectFilled({ -1000.0f, p2.y }, { 1000.0f, 1000.0f }, 0xFF000000);
            p->PopClipRect();
        }
    }
}
// void RenderBlindView(int ver, unsigned int device, float zoom)
// {
//     if (SSS::g_blind_view) {
//         switch (ver) {
//         case 10:
//             if (*(DWORD*)(0x00477834)) {
//                 SSS::RenderBlindView(9, *(ImVec2*)(*(DWORD*)0x00477834 + 0x3C0), { 192.0f, 0.0f }, device, zoom);
//             }
//             break;
//         case 12:
//             if (*(DWORD*)(0x004B4514)) {
//                 SSS::RenderBlindView(9, *(ImVec2*)(*(DWORD*)0x004B4514 + 0x97C), { 192.0f, 0.0f }, device, zoom);
//             }
//             break;
//         case 15:
//             if (*(DWORD*)(0x004E9BB8)) {
//                 SSS::RenderBlindView(9, *(ImVec2*)(*(DWORD*)0x004E9BB8 + 0x618), { 192.0f, 0.0f }, device, zoom);
//             }
//             break;
//         case 6:
//             if (*(DWORD*)(0x6C6EA4) == 2) {
//                 SSS::RenderBlindView(8, *(ImVec2*)(0x6CAA68), { 0.0f, 0.0f }, device, 1.0f);
//             }
//             break;
//         }
//     }
// }

void SSS_UI()
{
    if (ImGui::CollapsingHeader("Super Secret Settings")) {
        ImGui::Checkbox(S(THPRAC_BLIND), &g_blind_view);
        ImGui::SameLine();
        HelpMarker(S(THPRAC_BLIND_DESC));
        ImGui::SameLine();
        ImGui::SetNextItemWidth(75.0f);
        ImGui::DragFloat(S(THPRAC_BLIND_SZ), &g_blind_size, 1.0f, 20.0f, 600.0f);
        ImGui::SameLine();
        if (ImGui::Button(std::format("{}##blind_reload", S(THPRAC_INGAMEINFO_TH06_SHOW_HITBOX_RELOAD)).c_str())) {
            // if (g_blind_texture)
            //     ((IUnknown*)(g_blind_texture))->Release();
            g_blind_texture = NULL;
            g_is_texture_failed = false;
        }
    }
}

#pragma endregion
}