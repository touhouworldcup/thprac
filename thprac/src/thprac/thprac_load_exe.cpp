#define NOMINMAX

#include "thprac_load_exe.h"
#include "thprac_identify.h"
#include "utils/utils.h"
#include "utils/wininternal.h"

#include <tlhelp32.h>
#include <wchar.h>

#include <algorithm>
#include <string>

namespace THPrac {

// This array is generated by compiling inject_shellcode.cpp. Check the comment at the top of that file for more info.
unsigned char INJECT_SHELLCODE[] = {
    0x55, 0x53, 0x57, 0x56, 0x83, 0xEC, 0x38, 0x8B, 0x4C, 0x24, 0x4C, 0x8B, 0x41, 0x08, 0x8B, 0x51,
    0x0C, 0x89, 0x54, 0x24, 0x34, 0x8B, 0x51, 0x10, 0x89, 0x54, 0x24, 0x24, 0x8B, 0x51, 0x14, 0x89,
    0x54, 0x24, 0x20, 0x8B, 0x71, 0x18, 0x83, 0xC1, 0x1C, 0x51, 0xFF, 0xD0, 0x85, 0xC0, 0x0F, 0x84,
    0xA1, 0x02, 0x00, 0x00, 0x89, 0xC3, 0x8B, 0x40, 0x3C, 0x89, 0xD9, 0x89, 0x44, 0x24, 0x0C, 0x2B,
    0x4C, 0x03, 0x34, 0x89, 0x4C, 0x24, 0x04, 0x89, 0x5C, 0x24, 0x10, 0x89, 0x74, 0x24, 0x30, 0x0F,
    0x84, 0xDE, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x0C, 0x8B, 0x8C, 0x03, 0xA0, 0x00, 0x00, 0x00,
    0x85, 0xC9, 0x0F, 0x84, 0xCB, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x0C, 0x83, 0xBC, 0x03, 0xA4,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0xB9, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x0B, 0x04, 0x8B, 0x14,
    0x0B, 0x01, 0xC2, 0x0F, 0x84, 0xAA, 0x00, 0x00, 0x00, 0x8D, 0x2C, 0x0B, 0x8D, 0x34, 0x0B, 0x83,
    0xC6, 0x04, 0x8D, 0x48, 0xF8, 0x83, 0xF9, 0x02, 0x0F, 0x82, 0x80, 0x00, 0x00, 0x00, 0x89, 0x34,
    0x24, 0xD1, 0xE9, 0x31, 0xFF, 0x89, 0x6C, 0x24, 0x18, 0x89, 0x4C, 0x24, 0x08, 0x0F, 0xB7, 0x5C,
    0x7D, 0x08, 0x89, 0xD8, 0x25, 0x00, 0xF0, 0x00, 0x00, 0x3D, 0x00, 0x30, 0x00, 0x00, 0x75, 0x50,
    0x8B, 0x44, 0x24, 0x18, 0x8B, 0x28, 0x81, 0xE3, 0xFF, 0x0F, 0x00, 0x00, 0x03, 0x5C, 0x24, 0x10,
    0x8D, 0x14, 0x2B, 0x89, 0x54, 0x24, 0x14, 0x8D, 0x44, 0x24, 0x1C, 0x50, 0x6A, 0x40, 0xB8, 0x04,
    0x00, 0x00, 0x00, 0x50, 0x52, 0x8B, 0x74, 0x24, 0x34, 0xFF, 0xD6, 0x8B, 0x44, 0x24, 0x04, 0x01,
    0x44, 0x1D, 0x00, 0x8B, 0x6C, 0x24, 0x18, 0x8D, 0x44, 0x24, 0x1C, 0x50, 0xFF, 0x74, 0x24, 0x20,
    0xB8, 0x04, 0x00, 0x00, 0x00, 0x50, 0xFF, 0x74, 0x24, 0x20, 0xFF, 0xD6, 0x8B, 0x4C, 0x24, 0x08,
    0x47, 0x39, 0xF9, 0x75, 0x98, 0x8B, 0x04, 0x24, 0x8B, 0x00, 0x8B, 0x5C, 0x24, 0x10, 0x8D, 0x34,
    0x28, 0x83, 0xC6, 0x04, 0x01, 0xC5, 0x8B, 0x06, 0x8B, 0x56, 0xFC, 0x01, 0xC2, 0x0F, 0x85, 0x5F,
    0xFF, 0xFF, 0xFF, 0x8B, 0x44, 0x24, 0x0C, 0x8B, 0x8C, 0x03, 0x80, 0x00, 0x00, 0x00, 0x89, 0xC8,
    0x89, 0x4C, 0x24, 0x08, 0x85, 0xC9, 0x0F, 0x84, 0x2C, 0x01, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x0C,
    0x83, 0xBC, 0x03, 0x84, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x1A, 0x01, 0x00, 0x00, 0x8B, 0x44,
    0x24, 0x08, 0x8B, 0x7C, 0x03, 0x0C, 0x85, 0xFF, 0x0F, 0x84, 0x0A, 0x01, 0x00, 0x00, 0x01, 0x5C,
    0x24, 0x08, 0x8D, 0x43, 0x04, 0x89, 0x44, 0x24, 0x2C, 0x8D, 0x43, 0x01, 0x89, 0x44, 0x24, 0x28,
    0x66, 0xB8, 0x02, 0x00, 0x89, 0x44, 0x24, 0x04, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0x8B,
    0x74, 0x24, 0x24, 0x89, 0xDD, 0x01, 0xFB, 0x53, 0xFF, 0x54, 0x24, 0x38, 0x89, 0x44, 0x24, 0x14,
    0x85, 0xC0, 0x74, 0x6E, 0x8B, 0x44, 0x24, 0x08, 0x8B, 0x18, 0x8B, 0x78, 0x10, 0x85, 0xDB, 0x0F,
    0x44, 0xDF, 0x8B, 0x44, 0x1D, 0x00, 0x85, 0xC0, 0x74, 0x7D, 0x01, 0xEF, 0x03, 0x5C, 0x24, 0x2C,
    0x85, 0xC0, 0x78, 0x0B, 0x8B, 0x4C, 0x24, 0x10, 0x01, 0xC8, 0x83, 0xC0, 0x02, 0xEB, 0x03, 0x0F,
    0xB7, 0xC0, 0x50, 0xFF, 0x74, 0x24, 0x18, 0xFF, 0x54, 0x24, 0x28, 0x89, 0x44, 0x24, 0x18, 0x8D,
    0x44, 0x24, 0x1C, 0x50, 0x6A, 0x40, 0xBD, 0x04, 0x00, 0x00, 0x00, 0x55, 0x57, 0xFF, 0xD6, 0x8B,
    0x44, 0x24, 0x18, 0x89, 0x07, 0x8D, 0x44, 0x24, 0x1C, 0x50, 0xFF, 0x74, 0x24, 0x20, 0x55, 0x57,
    0xFF, 0xD6, 0x01, 0xEF, 0x8B, 0x03, 0x01, 0xEB, 0x85, 0xC0, 0x75, 0xB4, 0x8B, 0x5C, 0x24, 0x10,
    0xEB, 0x49, 0x8A, 0x03, 0x84, 0xC0, 0x74, 0x23, 0x03, 0x7C, 0x24, 0x28, 0x31, 0xC9, 0x8B, 0x54,
    0x24, 0x4C, 0x8B, 0x5C, 0x24, 0x10, 0x88, 0x84, 0x0A, 0x24, 0x02, 0x00, 0x00, 0x8A, 0x04, 0x0F,
    0x41, 0x84, 0xC0, 0x75, 0xF1, 0xEB, 0x0E, 0x89, 0xEB, 0xEB, 0x27, 0x31, 0xC9, 0x8B, 0x54, 0x24,
    0x4C, 0x8B, 0x5C, 0x24, 0x10, 0xC6, 0x84, 0x0A, 0x24, 0x02, 0x00, 0x00, 0x00, 0xFF, 0x54, 0x24,
    0x30, 0x89, 0x04, 0x24, 0x31, 0xC0, 0x40, 0x89, 0x44, 0x24, 0x04, 0x83, 0x7C, 0x24, 0x14, 0x00,
    0x74, 0x7F, 0x8B, 0x44, 0x24, 0x08, 0x8B, 0x78, 0x20, 0x83, 0xC0, 0x14, 0x89, 0x44, 0x24, 0x08,
    0x85, 0xFF, 0x0F, 0x85, 0x1B, 0xFF, 0xFF, 0xFF, 0x8B, 0x44, 0x24, 0x0C, 0x8B, 0x84, 0x03, 0xC0,
    0x00, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x3D, 0x8B, 0x74, 0x03, 0x0C, 0x85, 0xF6, 0x74, 0x19, 0x8B,
    0x06, 0x85, 0xC0, 0x74, 0x13, 0x83, 0xC6, 0x04, 0x6A, 0x00, 0x6A, 0x01, 0x53, 0xFF, 0xD0, 0x8B,
    0x06, 0x83, 0xC6, 0x04, 0x85, 0xC0, 0x75, 0xF0, 0x8B, 0x4C, 0x24, 0x4C, 0x8B, 0x01, 0x85, 0xC0,
    0x74, 0x06, 0x8B, 0x49, 0x04, 0x89, 0x04, 0x19, 0x8B, 0x44, 0x24, 0x0C, 0x8B, 0x44, 0x03, 0x28,
    0x01, 0xD8, 0xFF, 0xD0, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x04, 0x24, 0x00,
    0x00, 0x00, 0x00, 0xEB, 0x0C, 0xFF, 0xD6, 0x89, 0x04, 0x24, 0x31, 0xC0, 0x40, 0x89, 0x44, 0x24,
    0x04, 0x8B, 0x0C, 0x24, 0xC1, 0xE1, 0x10, 0x0F, 0xB7, 0x44, 0x24, 0x04, 0x09, 0xC8, 0x83, 0xC4,
    0x38, 0x5E, 0x5F, 0x5B, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
};

static_assert(sizeof(INJECT_SHELLCODE) % 16 == 0);

PIMAGE_NT_HEADERS GetNtHeader(HMODULE hMod)
{
    if (!hMod) {
        return 0;
    }
    PIMAGE_DOS_HEADER pDosH = (PIMAGE_DOS_HEADER)hMod;
    PIMAGE_NT_HEADERS pNTH = (PIMAGE_NT_HEADERS)((UINT_PTR)pDosH + pDosH->e_lfanew);
    return pNTH;
}

void* GetNtDataDirectory(HMODULE hMod, BYTE directory)
{
    if (PIMAGE_NT_HEADERS pNTH = GetNtHeader(hMod)) {
        if (UINT_PTR DirVA = pNTH->OptionalHeader.DataDirectory[directory].VirtualAddress) {
            return (BYTE*)hMod + DirVA;
        }
    }
    return NULL;
}

uintptr_t GetProcessModuleBase(HANDLE hProc)
{
    PROCESS_BASIC_INFORMATION pbi;
    if (NTSTATUS err = NtQueryInformationProcess(hProc, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr)) {
        //SetLastError(RtlNtStatusToDosError(err));
        return 0;
    }

    LPVOID based = (LPVOID)((uintptr_t)pbi.PebBaseAddress + offsetof(PEB, ImageBaseAddress));

    uintptr_t ret = 0;
    DWORD byteRet;
    
    // If this fails, it'll return 0 and GetLastError will already be set.
    ReadProcessMemory(hProc, based, &ret, sizeof(ret), &byteRet);

    return ret;
}


constexpr DWORD thpracSig = 'CARP'; // 🐟

bool WriteTHPracSig(HANDLE hProc, uintptr_t base) {
    DWORD sigAddr = 0;
    DWORD bytesReadRPM;
    ReadProcessMemory(hProc, (void*)(base + 0x3c), &sigAddr, 4, &bytesReadRPM);
    if (bytesReadRPM != 4 || !sigAddr)
        return false;
    sigAddr += base;
    sigAddr -= 4;

    DWORD bytesWrote;
    DWORD oldProtect;
    if (!VirtualProtectEx(hProc, (void*)sigAddr, 4, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        return false;
    }
    if (!WriteProcessMemory(hProc, (void*)sigAddr, &thpracSig, 4, &bytesWrote)) {
        return false;
    }
    if (!VirtualProtectEx(hProc, (void*)sigAddr, 4, oldProtect, &oldProtect)) {
        return false;
    }
    return true;
}

bool CheckTHPracSig(HANDLE hProc, uintptr_t base) {
    DWORD sigAddr;
    DWORD bytesReadRPM;
    if (!ReadProcessMemory(hProc, (void*)(base + 0x3c), &sigAddr, 4, &bytesReadRPM)) {
        return false;
    }
    sigAddr += base;
    sigAddr -= 4;

    DWORD sig;
    if (!ReadProcessMemory(hProc, (void*)sigAddr, &sig, 4, &bytesReadRPM)) {
        return false;
    }
    return sig == thpracSig;
}


const THGameVersion* CheckOngoingGameByPID(DWORD pid, uintptr_t* pOutBase, HANDLE* pOutHandle) {
    auto hProc = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
        FALSE, pid);
    if (!hProc)
        return nullptr;

    defer({
        if (pOutHandle) {
            *pOutHandle = hProc;
        } else {
            CloseHandle(hProc);
        }
    });

    uintptr_t base = GetProcessModuleBase(hProc);
    if (!base) {
        return nullptr;
    }
    if (pOutBase) {
        *pOutBase = base;
    }

    // Check THPrac signature
    // If an error happens here, return early
    if (CheckTHPracSig(hProc, base)) {
        return nullptr;
    }

    auto exeSig = GetRemoteExeInfo(hProc, base);
    for (size_t i = 0; i < gGameVersionsCount; i++) {
        uint64_t info_packed = (uint64_t)gGameVersions[i].textSize << 32 | gGameVersions[i].timeStamp;
        if (info_packed == exeSig) {
            return gGameVersions + i;
        }
    }
    return nullptr;
}

const wchar_t* mutexNames[] = {
    L"Touhou Koumakyou App",
    L"Touhou YouYouMu App",
    L"Touhou 08 App",
    L"Touhou 10 App",
    L"Touhou 11 App",
    L"Touhou 12 App",
    L"th17 App",
    L"th18 App",
    L"th185 App",
    L"th19 App",
    L"th20 App",
};

bool CheckIfAnyGame() {
    for (const wchar_t* mutexName : mutexNames) {
        HANDLE hMutex = OpenMutexW(SYNCHRONIZE, FALSE, mutexName);
        if (hMutex) {
            CloseHandle(hMutex);
            return true;
        }
    }
    return false;
}

bool LoadSelf(HANDLE hProcess, void* userdata, size_t userdataSize)
{
    remote_param lModule = {
        .pLoadLibraryW = LoadLibraryW,
        .pLoadLibraryA = LoadLibraryA,
        .pVirtualProtect = VirtualProtect,
        .pGetProcAddress = GetProcAddress,
        .pGetLastError = GetLastError,
    };
    GetModuleFileNameW(NULL, lModule.sExePath, MAX_PATH);

    // User data
    if (userdata) {
        if (auto rUserData = VirtualAllocEx(hProcess, nullptr, userdataSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) {
            WriteProcessMemory(hProcess, rUserData, userdata, userdataSize, nullptr);
            lModule.pUserData = rUserData;
            lModule.pAddrOfUserData = (PUINT8)((PUINT8)GetUserData() - (PUINT8)GetModuleHandleA(nullptr));
        }
    }    

    // Write shellcode and parameters
    LPVOID rModule = VirtualAllocEx(hProcess, nullptr, sizeof(remote_param), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!rModule)
        return false;
    defer(VirtualFreeEx(hProcess, rModule, 0, MEM_RELEASE));
    WriteProcessMemory(hProcess, rModule, &lModule, sizeof(remote_param), nullptr);
    LPVOID pRemoteInit = VirtualAllocEx(hProcess, nullptr, sizeof(INJECT_SHELLCODE), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!pRemoteInit)
        return false;
    defer(VirtualFreeEx(hProcess, pRemoteInit, 0, MEM_RELEASE));
    WriteProcessMemory(hProcess, pRemoteInit, INJECT_SHELLCODE, sizeof(INJECT_SHELLCODE), nullptr);

    // Invoke
    InjectResult rResult;
    if (auto tInit = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE)pRemoteInit, rModule, 0, nullptr)) {
        WaitForSingleObject(tInit, INFINITE);
        GetExitCodeThread(tInit, (DWORD*)&rResult);
    } else {
        return false;
    }
    DWORD byteRet;
    ReadProcessMemory(hProcess, rModule, &lModule, sizeof(remote_param), &byteRet);

    if (rResult.error != InjectResult::Ok)
        return false;

    return true;
}

bool ApplyToProcById(DWORD pid) {

    uintptr_t base;
    HANDLE hProc;
    auto* sig = THPrac::CheckOngoingGameByPID(pid, &base, &hProc);
    if (sig) {
        if (!WriteTHPracSig(hProc, base) || !LoadSelf(hProc)) {
            //fprintf(stderr, "Error: failed to inject into PID %d\n", pid);
            return false;
        }
    } else {
        //fprintf(stderr, "Warning: PID %d is invalid. Is it a Touhou game? Is thprac already applied\n", pid);
        return false;
    }

    if (hProc) {
        CloseHandle(hProc);
    }
    return true;
}

enum thprac_prompt_t {
    PR_FAILED,
    PR_INFO_ATTACHED,
    PR_INFO_NO_GAME_FOUND,
    PR_ASK_IF_ATTACH,
    PR_ASK_IF_CONTINUE,
    PR_ASK_USE_VPATCH,
    PR_ERR_NO_GAME_FOUND,
    PR_ERR_ATTACH_FAILED,
    PR_ERR_RUN_FAILED,
};

bool FindAndAttach(bool prompt_if_no_game, bool prompt_if_yes_game) {
    bool hasPrompted = false;

    if (CheckIfAnyGame()) {
        const THGameVersion* gameSig = nullptr;
        PROCESSENTRY32W entry = {};
        entry.dwSize = sizeof(PROCESSENTRY32W);
        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (Process32FirstW(snapshot, &entry)) {
            do {
                uintptr_t base;
                HANDLE hProc = 0;
                if (!(gameSig = CheckOngoingGameByPID(entry.th32ProcessID, &base, &hProc)))
                    continue;

                hasPrompted = true;
                if (prompt_if_yes_game) {
                    wchar_t gameWcs[8] = {};
                    {
                        const char* gameStr = gThGameStrs[gameSig->gameId];
                        for (size_t i = 0; gameStr[i]; i++) {
                            gameWcs[i] = gameStr[i];
                        }
                    }

                    wchar_t buf[64] = {};
                    _snwprintf(buf, 63, L"Fount game %s\nAttach thprac?", gameWcs);

                    int choice = MessageBoxW(NULL, buf, L"TODO: add translation support here", MB_YESNO);

                    if (choice != IDYES)
                        continue;
                }
                if (WriteTHPracSig(hProc, base) && LoadSelf(hProc)) {
                    if (prompt_if_yes_game) {
                        MessageBoxW(NULL, L"Applied thprac.\nIf nothing happened, return to main menu in game once.", L"TODO: add translation support here", MB_OK);
                    }
                    CloseHandle(snapshot);
                    return true;
                } else {
                    MessageBoxW(NULL, L"Failed to apply thprac", L"TODO: add translation support here", MB_ICONERROR | MB_OK);
                    CloseHandle(snapshot);
                    return true;
                }

            } while (Process32NextW(snapshot, &entry));
        }
    }

    if (prompt_if_no_game && !hasPrompted) {
        MessageBoxW(NULL, L"No valid game was found.", L"TODO: add translation support here", MB_ICONERROR | MB_OK);
    }

    return false;
}

void RunGameWithTHPrac(const wchar_t* exeFn, wchar_t* cmdLine) {
    STARTUPINFOW si = {
        .cb = sizeof(si),
    };
    PROCESS_INFORMATION pi = {};

    const wchar_t* file_spec = std::max(wcsrchr(exeFn, L'\\'), wcsrchr(exeFn, L'/'));
    BOOL ret;
    if (file_spec) {
        std::wstring exeDir(exeFn, file_spec);
        ret = CreateProcessW(exeFn, cmdLine, nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, exeDir.c_str(), &si, &pi);
    } else {
        ret = CreateProcessW(exeFn, cmdLine, nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, nullptr, &si, &pi);
    }

    if (!ret) {
        return;
    }
    
    LoadSelf(pi.hProcess, nullptr, 0);
    ResumeThread(pi.hThread);

    // TODO: determine if these should be returned
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}



void** GetUserData()
{
    static void* userdata = nullptr;
    return &userdata;
}
}
