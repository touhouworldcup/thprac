#define NOMINMAX

#include "thprac_load_exe.h"
#include "thprac_identify.h"
#include "thprac_log.h"
#include "thprac_gui_locale.h"
#include "thprac_utils.h"
#include "utils/utils.h"
#include "utils/wininternal.h"

#include <tlhelp32.h>
#include <wchar.h>

#include <algorithm>
#include <string>

namespace THPrac {

// This array is generated by compiling inject_shellcode.cpp. Check the comment at the top of that file for more info.
unsigned char INJECT_SHELLCODE[] = {
    0x55, 0x53, 0x57, 0x56, 0x83, 0xEC, 0x24, 0x8B, 0x74, 0x24, 0x38, 0x8D, 0x46, 0x14, 0x50, 0xFF,
    0x56, 0x04, 0x85, 0xC0, 0x0F, 0x84, 0x03, 0x02, 0x00, 0x00, 0x89, 0xC5, 0x8B, 0x06, 0x89, 0x34,
    0x28, 0x8B, 0x45, 0x3C, 0x89, 0xE9, 0x89, 0x04, 0x24, 0x2B, 0x4C, 0x05, 0x34, 0x89, 0x4C, 0x24,
    0x0C, 0x89, 0x6C, 0x24, 0x18, 0x74, 0x2B, 0x8B, 0x04, 0x24, 0x8B, 0x8C, 0x05, 0xA0, 0x00, 0x00,
    0x00, 0x85, 0xC9, 0x74, 0x1D, 0x8B, 0x04, 0x24, 0x83, 0xBC, 0x05, 0xA4, 0x00, 0x00, 0x00, 0x00,
    0x74, 0x10, 0x8B, 0x44, 0x0D, 0x04, 0x8B, 0x54, 0x0D, 0x00, 0x01, 0xC2, 0x0F, 0x85, 0xCE, 0x01,
    0x00, 0x00, 0x8B, 0x04, 0x24, 0x8B, 0x8C, 0x05, 0x80, 0x00, 0x00, 0x00, 0x85, 0xC9, 0x0F, 0x84,
    0x5C, 0x01, 0x00, 0x00, 0x8B, 0x04, 0x24, 0x83, 0xBC, 0x05, 0x84, 0x00, 0x00, 0x00, 0x00, 0x0F,
    0x84, 0x4B, 0x01, 0x00, 0x00, 0x8B, 0x74, 0x0D, 0x0C, 0x85, 0xF6, 0x0F, 0x84, 0x3F, 0x01, 0x00,
    0x00, 0x01, 0xE9, 0x8D, 0x45, 0x02, 0x89, 0x44, 0x24, 0x14, 0x8D, 0x45, 0x04, 0x89, 0x44, 0x24,
    0x20, 0x8D, 0x45, 0x01, 0x89, 0x44, 0x24, 0x1C, 0xBB, 0x00, 0x00, 0x00, 0x20, 0xEB, 0x21, 0x90,
    0x8B, 0x6C, 0x24, 0x18, 0x8B, 0x5C, 0x24, 0x10, 0x83, 0x7C, 0x24, 0x04, 0x00, 0x8B, 0x4C, 0x24,
    0x0C, 0x0F, 0x85, 0xFB, 0x00, 0x00, 0x00, 0xE9, 0x58, 0x01, 0x00, 0x00, 0x0F, 0x1F, 0x40, 0x00,
    0x89, 0x4C, 0x24, 0x0C, 0x8D, 0x3C, 0x2E, 0x57, 0x8B, 0x44, 0x24, 0x3C, 0xFF, 0x50, 0x08, 0x89,
    0x44, 0x24, 0x04, 0x85, 0xC0, 0x0F, 0x84, 0x85, 0x00, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x0C, 0x8B,
    0x31, 0x8B, 0x79, 0x10, 0x85, 0xF6, 0x0F, 0x44, 0xF7, 0x8B, 0x44, 0x35, 0x00, 0x85, 0xC0, 0x0F,
    0x84, 0xBD, 0x00, 0x00, 0x00, 0x89, 0x5C, 0x24, 0x10, 0x01, 0xEF, 0x03, 0x74, 0x24, 0x20, 0x8B,
    0x6C, 0x24, 0x38, 0xEB, 0x4A, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x44, 0x24, 0x14, 0x50, 0xFF, 0x74, 0x24, 0x08, 0xFF, 0xD1, 0x89, 0xC3, 0x8D, 0x44, 0x24,
    0x08, 0x50, 0x6A, 0x40, 0x6A, 0x04, 0x57, 0x8B, 0x6C, 0x24, 0x48, 0xFF, 0x55, 0x0C, 0x89, 0x1F,
    0x8D, 0x44, 0x24, 0x08, 0x50, 0xFF, 0x74, 0x24, 0x0C, 0x6A, 0x04, 0x57, 0xFF, 0x55, 0x0C, 0x83,
    0xC7, 0x04, 0x8B, 0x06, 0x83, 0xC6, 0x04, 0x85, 0xC0, 0x0F, 0x84, 0x51, 0xFF, 0xFF, 0xFF, 0x8B,
    0x4D, 0x10, 0x85, 0xC0, 0x79, 0xBA, 0x0F, 0xB7, 0xC0, 0xEB, 0xB9, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x0F, 0xB6, 0x07, 0x84, 0xC0, 0x74, 0x2B, 0x03, 0x74, 0x24, 0x1C, 0x31, 0xC9, 0x8B, 0x54, 0x24,
    0x38, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x88, 0x84, 0x0A, 0x1C, 0x02, 0x00, 0x00, 0x0F, 0xB6, 0x04, 0x0E, 0x41, 0x84, 0xC0, 0x75, 0xF0,
    0xEB, 0x06, 0x31, 0xC9, 0x8B, 0x54, 0x24, 0x38, 0xC6, 0x84, 0x0A, 0x1C, 0x02, 0x00, 0x00, 0x00,
    0x64, 0x8B, 0x1D, 0x34, 0x00, 0x00, 0x00, 0x83, 0x7C, 0x24, 0x04, 0x00, 0x8B, 0x4C, 0x24, 0x0C,
    0x74, 0x62, 0x8B, 0x71, 0x20, 0x83, 0xC1, 0x14, 0x85, 0xF6, 0x0F, 0x85, 0x00, 0xFF, 0xFF, 0xFF,
    0x8B, 0x04, 0x24, 0x8B, 0x84, 0x05, 0xC0, 0x00, 0x00, 0x00, 0x31, 0xDB, 0x85, 0xC0, 0x74, 0x44,
    0x8B, 0x74, 0x05, 0x0C, 0x85, 0xF6, 0x74, 0x28, 0x8B, 0x06, 0x85, 0xC0, 0x74, 0x22, 0x83, 0xC6,
    0x04, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6A, 0x00, 0x6A, 0x01, 0x55, 0xFF, 0xD0, 0x8B, 0x06, 0x83, 0xC6, 0x04, 0x85, 0xC0, 0x75, 0xF0,
    0x8B, 0x04, 0x24, 0x8B, 0x44, 0x05, 0x28, 0x01, 0xE8, 0xFF, 0xD0, 0xEB, 0x07, 0x64, 0x8B, 0x1D,
    0x34, 0x00, 0x00, 0x00, 0x89, 0xD8, 0x83, 0xC4, 0x24, 0x5E, 0x5F, 0x5B, 0x5D, 0xC2, 0x04, 0x00,
    0x8D, 0x1C, 0x29, 0x8D, 0x3C, 0x29, 0x83, 0xC7, 0x04, 0xEB, 0x27, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x8B, 0x44, 0x24, 0x10, 0x8B, 0x00, 0x8D, 0x0C, 0x03, 0x8D, 0x3C, 0x03, 0x83, 0xC7, 0x04, 0x8B,
    0x14, 0x03, 0x8B, 0x74, 0x03, 0x04, 0x89, 0xF0, 0x89, 0xCB, 0x01, 0xF2, 0x0F, 0x84, 0x00, 0xFE,
    0xFF, 0xFF, 0x8D, 0x48, 0xF8, 0x83, 0xF9, 0x02, 0x72, 0xDC, 0x89, 0x7C, 0x24, 0x10, 0xD1, 0xE9,
    0x31, 0xF6, 0x89, 0x4C, 0x24, 0x14, 0xEB, 0x0D, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x46, 0x39, 0xF1, 0x74, 0xBB, 0x0F, 0xB7, 0x7C, 0x73, 0x08, 0x89, 0xF8, 0x25, 0x00, 0xF0, 0x00,
    0x00, 0x3D, 0x00, 0x30, 0x00, 0x00, 0x75, 0xE8, 0x89, 0xE8, 0x89, 0xDD, 0x8B, 0x1B, 0x81, 0xE7,
    0xFF, 0x0F, 0x00, 0x00, 0x01, 0xC7, 0x8D, 0x14, 0x1F, 0x89, 0x54, 0x24, 0x04, 0x8D, 0x44, 0x24,
    0x08, 0x50, 0x6A, 0x40, 0x6A, 0x04, 0x52, 0x8B, 0x44, 0x24, 0x48, 0xFF, 0x50, 0x0C, 0x8B, 0x44,
    0x24, 0x0C, 0x01, 0x04, 0x3B, 0x89, 0xEB, 0x8D, 0x44, 0x24, 0x08, 0x50, 0xFF, 0x74, 0x24, 0x0C,
    0x6A, 0x04, 0xFF, 0x74, 0x24, 0x10, 0x8B, 0x6C, 0x24, 0x28, 0x8B, 0x44, 0x24, 0x48, 0xFF, 0x50,
    0x0C, 0x8B, 0x4C, 0x24, 0x14, 0xEB, 0x99, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
};

static_assert(sizeof(INJECT_SHELLCODE) % 16 == 0);

UINT_PTR gRemoteParamAddr = 0;

remote_init_config* RemoteGetConfig() {
    if (!gRemoteParamAddr) {
        return nullptr;
    } else {
        return (remote_init_config*)(gRemoteParamAddr + sizeof(remote_param) + sizeof(INJECT_SHELLCODE));
    }
}

bool CheckDLLFunction(const wchar_t* path, const char* funcName) {
    MappedFile file(path);

    auto exeSize = file.fileSize;
    auto exeBuffer = file.fileMapView;
    if (exeSize < 128)
        return 0;
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)exeBuffer;
    if (!pDosHeader || pDosHeader->e_magic != 0x5a4d || (size_t)pDosHeader->e_lfanew + 512 >= exeSize)
        return 0;
    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)exeBuffer + pDosHeader->e_lfanew);
    if (!pNtHeader || pNtHeader->Signature != 0x00004550)
        return 0;
    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNtHeader);
    if (!pSection)
        return 0;

    if (pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != 0 && pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size != 0) {
        auto pExportSectionVA = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        for (DWORD i = 0; i < pNtHeader->FileHeader.NumberOfSections; i++, pSection++) {
            if (pSection->VirtualAddress <= pExportSectionVA && pSection->VirtualAddress + pSection->SizeOfRawData > pExportSectionVA) {
                auto pSectionBase = (DWORD)exeBuffer - pSection->VirtualAddress + pSection->PointerToRawData;
                PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(pSectionBase + pExportSectionVA);
                char** pExportNames = (char**)(pSectionBase + pExportDirectory->AddressOfNames);
                for (DWORD j = 0; j < pExportDirectory->NumberOfNames; ++j) {
                    auto pFunctionName = (char*)(pSectionBase + pExportNames[j]);
                    if (!strcmp(pFunctionName, funcName)) {
                        return true;
                    }
                }
            }
        }
    }

    return true;
}

PIMAGE_NT_HEADERS GetNtHeader(HMODULE hMod)
{
    if (!hMod) {
        return 0;
    }
    PIMAGE_DOS_HEADER pDosH = (PIMAGE_DOS_HEADER)hMod;
    PIMAGE_NT_HEADERS pNTH = (PIMAGE_NT_HEADERS)((UINT_PTR)pDosH + pDosH->e_lfanew);
    return pNTH;
}

void* GetNtDataDirectory(HMODULE hMod, BYTE directory)
{
    if (PIMAGE_NT_HEADERS pNTH = GetNtHeader(hMod)) {
        if (UINT_PTR DirVA = pNTH->OptionalHeader.DataDirectory[directory].VirtualAddress) {
            return (BYTE*)hMod + DirVA;
        }
    }
    return NULL;
}

uintptr_t GetProcessModuleBase(HANDLE hProc)
{
    PROCESS_BASIC_INFORMATION pbi;
    if (NTSTATUS err = NtQueryInformationProcess(hProc, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr)) {
        //SetLastError(RtlNtStatusToDosError(err));
        return 0;
    }

    LPVOID based = (LPVOID)((uintptr_t)pbi.PebBaseAddress + offsetof(PEB, ImageBaseAddress));

    uintptr_t ret = 0;
    DWORD byteRet;
    
    // If this fails, it'll return 0 and GetLastError will already be set.
    ReadProcessMemory(hProc, based, &ret, sizeof(ret), &byteRet);

    return ret;
}


constexpr DWORD thpracSig = 'CARP'; // 🐟

bool WriteTHPracSig(HANDLE hProc, uintptr_t base) {
    DWORD sigAddr = 0;
    DWORD bytesReadRPM;
    ReadProcessMemory(hProc, (void*)(base + 0x3c), &sigAddr, 4, &bytesReadRPM);
    if (bytesReadRPM != 4 || !sigAddr)
        return false;
    sigAddr += base;
    sigAddr -= 4;

    DWORD bytesWrote;
    DWORD oldProtect;
    if (!VirtualProtectEx(hProc, (void*)sigAddr, 4, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        return false;
    }
    if (!WriteProcessMemory(hProc, (void*)sigAddr, &thpracSig, 4, &bytesWrote)) {
        return false;
    }
    if (!VirtualProtectEx(hProc, (void*)sigAddr, 4, oldProtect, &oldProtect)) {
        return false;
    }
    return true;
}

bool CheckTHPracSig(HANDLE hProc, uintptr_t base) {
    DWORD sigAddr;
    DWORD bytesReadRPM;
    if (!ReadProcessMemory(hProc, (void*)(base + 0x3c), &sigAddr, 4, &bytesReadRPM)) {
        return false;
    }
    sigAddr += base;
    sigAddr -= 4;

    DWORD sig;
    if (!ReadProcessMemory(hProc, (void*)sigAddr, &sig, 4, &bytesReadRPM)) {
        return false;
    }
    return sig == thpracSig;
}


const THGameVersion* CheckOngoingGameByPID(DWORD pid, uintptr_t* pOutBase, HANDLE* pOutHandle) {
    auto hProc = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
        FALSE, pid);
    if (!hProc)
        return nullptr;

    defer({
        if (pOutHandle) {
            *pOutHandle = hProc;
        } else {
            CloseHandle(hProc);
        }
    });

    uintptr_t base = GetProcessModuleBase(hProc);
    if (!base) {
        return nullptr;
    }
    if (pOutBase) {
        *pOutBase = base;
    }

    // Check THPrac signature
    // If an error happens here, return early
    if (CheckTHPracSig(hProc, base)) {
        return nullptr;
    }

    auto exeSig = GetRemoteExeInfo(hProc, base);
    for (size_t i = 0; i < gGameVersionsCount; i++) {
        if (exeSig == gGameVersions[i].exeInfo) {
            return gGameVersions + i;
        }
    }
    return nullptr;
}

const wchar_t* mutexNames[] = {
    L"Touhou Koumakyou App",
    L"Touhou YouYouMu App",
    L"Touhou 08 App",
    L"Touhou 10 App",
    L"Touhou 11 App",
    L"Touhou 12 App",
    L"th17 App",
    L"th18 App",
    L"th185 App",
    L"th19 App",
    L"th20 App",
};

bool CheckIfAnyGame() {
    for (const wchar_t* mutexName : mutexNames) {
        HANDLE hMutex = OpenMutexW(SYNCHRONIZE, FALSE, mutexName);
        if (hMutex) {
            CloseHandle(hMutex);
            return true;
        }
    }
    return false;
}

bool LoadSelf(HANDLE hProcess, remote_init_config* conf) {
    constexpr unsigned int buf_len = sizeof(remote_param) + sizeof(INJECT_SHELLCODE) + sizeof(remote_init_config);

    remote_init_config nullConf = {};
    if (!conf) {
        conf = &nullConf;
    }

    BYTE* rBuf = (BYTE*)VirtualAllocEx(hProcess, nullptr, buf_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!rBuf) {
        return false;
    }
    defer(VirtualFreeEx(hProcess, rBuf, 0, MEM_RELEASE));	
	
	remote_param lModule = {
		.pRemoteParamAddr = (UINT_PTR)&gRemoteParamAddr - (UINT_PTR)&__ImageBase,
        .pLoadLibraryW = LoadLibraryW,
        .pLoadLibraryA = LoadLibraryA,
        .pVirtualProtect = VirtualProtect,
        .pGetProcAddress = GetProcAddress,
    };
    GetModuleFileNameW((HMODULE)&__ImageBase, lModule.sExePath, MAX_PATH);
	
	WriteProcessMemory(hProcess, rBuf, &lModule, sizeof(lModule), nullptr);
	WriteProcessMemory(hProcess, rBuf + sizeof(lModule), SIZED(INJECT_SHELLCODE), nullptr);
	WriteProcessMemory(hProcess, rBuf + sizeof(lModule) + sizeof(INJECT_SHELLCODE), conf, sizeof(*conf), nullptr);
	
	DWORD rResult = 1;
	if(auto tInit = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE)(rBuf + sizeof(remote_param)), rBuf, 0, nullptr)) {
        WaitForSingleObject(tInit, INFINITE);
        GetExitCodeThread(tInit, &rResult);
	} else {
        return false;
	}
	
	return !rResult;
}

bool ApplyToProcById(DWORD pid) {
    remote_init_config conf = {
        .newProcess = false
    };
    uintptr_t base;
    HANDLE hProc;
    auto* sig = THPrac::CheckOngoingGameByPID(pid, &base, &hProc);
    if (sig) {
        if (!WriteTHPracSig(hProc, base) || !LoadSelf(hProc, &conf)) {
            //fprintf(stderr, "Error: failed to inject into PID %d\n", pid);
            return false;
        }
    } else {
        //fprintf(stderr, "Warning: PID %d is invalid. Is it a Touhou game? Is thprac already applied\n", pid);
        return false;
    }

    if (hProc) {
        CloseHandle(hProc);
    }
    return true;
}

enum thprac_prompt_t {
    PR_FAILED,
    PR_INFO_ATTACHED,
    PR_INFO_NO_GAME_FOUND,
    PR_ASK_IF_ATTACH,
    PR_ASK_IF_CONTINUE,
    PR_ASK_USE_VPATCH,
    PR_ERR_NO_GAME_FOUND,
    PR_ERR_ATTACH_FAILED,
    PR_ERR_RUN_FAILED,
};

bool FindAndAttach(bool prompt_if_no_game, bool prompt_if_yes_game) {
    bool hasPrompted = false;

    remote_init_config conf = {
        .newProcess = false
    };

    if (CheckIfAnyGame()) {
        const THGameVersion* gameSig = nullptr;
        PROCESSENTRY32W entry = {};
        entry.dwSize = sizeof(PROCESSENTRY32W);
        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (Process32FirstW(snapshot, &entry)) {
            do {
                uintptr_t base;
                HANDLE hProc = 0;
                if (!(gameSig = CheckOngoingGameByPID(entry.th32ProcessID, &base, &hProc)))
                    continue;

                hasPrompted = true;
                if (prompt_if_yes_game) {
                    int choice = log_mboxf(0, MB_YESNO, S(THPRAC_PR_APPLY), S(THPRAC_PR_ASK_ATTACH), gThGameStrs[gameSig->gameId]);
                    if (choice != IDYES)
                        continue;
                }
                if (WriteTHPracSig(hProc, base) && LoadSelf(hProc, &conf)) {
                    if (prompt_if_yes_game) {
                        log_mbox(0, MB_ICONASTERISK | MB_OK, S(THPRAC_PR_COMPLETE), S(THPRAC_PR_INFO_ATTACHED));
                    }
                    CloseHandle(snapshot);
                    return true;
                } else {
                    log_mbox(0, MB_ICONERROR | MB_OK, S(THPRAC_PR_ERROR), S(THPRAC_PR_ERR_ATTACH));
                    CloseHandle(snapshot);
                    return true;
                }

            } while (Process32NextW(snapshot, &entry));
        }
    }

    if (prompt_if_no_game && !hasPrompted) {
        log_mbox(0, MB_ICONERROR | MB_OK, S(THPRAC_PR_ERROR), S(THPRAC_PR_ERR_NO_GAME));
    }

    return false;
}

void RunGameWithTHPrac(const wchar_t* exeFn, wchar_t* cmdLine, remote_init_config* conf) {
    remote_init_config nullConf = {
        .newProcess = true,
    };
    if (conf) {
        conf->newProcess = true;
    } else {
        conf = &nullConf;
    }
    
    STARTUPINFOW si = {
        .cb = sizeof(si),
    };
    PROCESS_INFORMATION pi = {};

    const wchar_t* file_spec = std::max(wcsrchr(exeFn, L'\\'), wcsrchr(exeFn, L'/'));
    BOOL ret;
    if (file_spec) {
        std::wstring exeDir(exeFn, file_spec);
        ret = CreateProcessW(exeFn, cmdLine, nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, exeDir.c_str(), &si, &pi);
    } else {
        ret = CreateProcessW(exeFn, cmdLine, nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, nullptr, &si, &pi);
    }

    if (!ret) {
        return;
    }
    
    LoadSelf(pi.hProcess, conf);
    ResumeThread(pi.hThread);

    // TODO: determine if these should be returned
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}


}
